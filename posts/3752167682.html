<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>14｜工具和工具箱：LangChain中的Tool和Toolkits一览 | geekbang</title><meta name="author" content="码农张三"><meta name="copyright" content="码农张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="14｜工具和工具箱：LangChain中的Tool和Toolkits一览你好，我是黄佳，欢迎来到LangChain实战课！ 这节课我们来一起看一看LangChain中各种强大的工具（Tool），以及如何使用它们。 在之前的几节课中，我们深入讲解了LangChain中的代理。未来的AI Agent，应该就是以LLM为核心控制器的代理系统。而 工具，则是代理身上延展出的三头六臂，是代理的武器，代理通过">
<meta property="og:type" content="article">
<meta property="og:title" content="14｜工具和工具箱：LangChain中的Tool和Toolkits一览">
<meta property="og:url" content="https://zhuansun.github.io/geekbang/posts/3752167682.html">
<meta property="og:site_name" content="geekbang">
<meta property="og:description" content="14｜工具和工具箱：LangChain中的Tool和Toolkits一览你好，我是黄佳，欢迎来到LangChain实战课！ 这节课我们来一起看一看LangChain中各种强大的工具（Tool），以及如何使用它们。 在之前的几节课中，我们深入讲解了LangChain中的代理。未来的AI Agent，应该就是以LLM为核心控制器的代理系统。而 工具，则是代理身上延展出的三头六臂，是代理的武器，代理通过">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg">
<meta property="article:published_time" content="2023-10-20T09:48:40.000Z">
<meta property="article:modified_time" content="2023-12-13T15:17:15.915Z">
<meta property="article:author" content="码农张三">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/geekbang/posts/3752167682"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '14｜工具和工具箱：LangChain中的Tool和Toolkits一览',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-13 15:17:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geekbang" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/653470a0c458853aef5813f1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">870</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geekbang</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">14｜工具和工具箱：LangChain中的Tool和Toolkits一览</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-10-20T09:48:40.000Z" title="发表于 2023-10-20 09:48:40">2023-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LangChain%E5%AE%9E%E6%88%98%E8%AF%BE/">LangChain实战课</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="14｜工具和工具箱：LangChain中的Tool和Toolkits一览"><a href="#14｜工具和工具箱：LangChain中的Tool和Toolkits一览" class="headerlink" title="14｜工具和工具箱：LangChain中的Tool和Toolkits一览"></a>14｜工具和工具箱：LangChain中的Tool和Toolkits一览</h1><p>你好，我是黄佳，欢迎来到LangChain实战课！</p>
<p>这节课我们来一起看一看LangChain中各种强大的工具（Tool），以及如何使用它们。</p>
<p>在之前的几节课中，我们深入讲解了LangChain中的代理。未来的AI Agent，应该就是以LLM为核心控制器的代理系统。而 <strong>工具，则是代理身上延展出的三头六臂，是代理的武器，代理通过工具来与世界进行交互，控制并改造世界</strong>。</p>
<h2 id="工具是代理的武器"><a href="#工具是代理的武器" class="headerlink" title="工具是代理的武器"></a>工具是代理的武器</h2><p>LangChain之所以强大，第一是大模型的推理能力强大，第二则是工具的执行能力强大！孙猴子法力再强，没有金箍棒，也降伏不了妖怪。大模型再能思考，没有工具也不行。</p>
<p>工具是代理可以用来与世界交互的功能。这些工具可以是通用实用程序（例如搜索），也可以是其他链，甚至其他的代理。</p>
<p>那么到底什么是工具？在LangChain中，工具是如何发挥作用的？</p>
<p>LangChain通过提供一个统一的框架来集成功能的具体实现。在这个框架中，每个功能都被封装成一个工具。每个工具都有自己的输入和输出，以及处理这些输入和生成输出的方法。</p>
<p>当代理接收到一个任务时，它会根据任务的类型和需求，通过大模型的推理，来选择合适的工具处理这个任务。这个选择过程可以基于各种策略，例如基于工具的性能，或者基于工具处理特定类型任务的能力。</p>
<p>一旦选择了合适的工具，LangChain就会将任务的输入传递给这个工具，然后工具会处理这些输入并生成输出。这个输出又经过大模型的推理，可以被用作其他工具的输入，或者作为最终结果，被返回给用户。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/ebcyyaccd79133c03f417c45c225d1b6.png"></p>
<p>通过这种方式，LangChain 大大延展了大模型的功能。大模型的推理，加上工具的调用，都集成在一个系统中，而这个系统可以处理多种类型的任务。这提高了系统的灵活性和可扩展性，也大大简化了开发者的工作。</p>
<h2 id="如何加载工具"><a href="#如何加载工具" class="headerlink" title="如何加载工具"></a>如何加载工具</h2><p>在程序中，可以使用以下代码片段加载工具。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">from langchain.agents import load_tools
tool_names = [...]
tools = load_tools(tool_names)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>某些工具（例如链、代理）可能需要 LLM 来初始化它们。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">from langchain.agents import load_tools
tool_names = [...]
llm = ...
tools = load_tools(tool_names, llm=llm)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="LangChain-支持的工具一览"><a href="#LangChain-支持的工具一览" class="headerlink" title="LangChain 支持的工具一览"></a>LangChain 支持的工具一览</h2><p>下面，我给你列出目前LangChain中所支持的工具。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/e2f8a0318b4f1da7f0e756e87761d95b.jpg"></p>
<p>当然这个列表随着时间的推移会越来越长，也就意味着LangChain的功能会越来越强大。</p>
<h2 id="使用-arXiv-工具开发科研助理"><a href="#使用-arXiv-工具开发科研助理" class="headerlink" title="使用 arXiv 工具开发科研助理"></a>使用 arXiv 工具开发科研助理</h2><p>其中有一些工具，比如SerpAPI，你已经用过了，这里我们再来用一下arXiv工具。arXiv本身就是一个论文研究的利器，里面的论文数量比AI顶会还早、还多、还全。那么把它以工具的形式集成到LangChain中，能让你在研究学术最新进展时如虎添翼。</p>
<blockquote>
<p>arXiv是一个提供免费访问的预印本库，供研究者在正式出版前上传和分享其研究工作。它成立于1991年，最初是作为物理学预印本数据库开始的，但后来扩展到了数学、计算机科学、生物学、经济学等多个领域。</p>
<p>预印本是研究者完成的、但尚未经过同行评议或正式出版的论文。Arxiv允许研究者上传这些预印本，使其他研究者可以在正式出版之前查看、评论和使用这些工作。这样，研究的发现可以更快地传播和分享，促进学术交流。</p>
</blockquote>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 设置OpenAI API的密钥
import os
os.environ["OPENAI_API_KEY"] = 'Your Key'

# 导入库
from langchain.chat_models import ChatOpenAI
from langchain.agents import load_tools, initialize_agent, AgentType

# 初始化模型和工具
llm = ChatOpenAI(temperature=0.0)
tools = load_tools(
    ["arxiv"],
)

# 初始化链
agent_chain = initialize_agent(
    tools,
    llm,
    agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION,
    verbose=True,
)

# 运行链
agent_chain.run("介绍一下2005.14165这篇论文的创新点?")
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>首先，我们还是来研究一下ZERO_SHOT_REACT_DESCRIPTION这个Agent是怎么通过提示来引导模型调用工具的。</p>
<blockquote>
<p>“prompts”: [</p>
<p>    “Answer the following questions as best you can. You have access to the following tools:\n\n</p>
</blockquote>
<p>首先告诉模型，要尽力回答问题，但是可以访问下面的工具。</p>
<blockquote>
<p><strong>arxiv:</strong> A wrapper around Arxiv.org Useful for when you need to answer questions about Physics, Mathematics, Computer Science, Quantitative Biology, Quantitative Finance, Statistics, Electrical Engineering, and Economics from scientific articles on arxiv.org. Input should be a search query.\n\n</p>
</blockquote>
<p>arxiv工具：一个围绕Arxiv.org的封装工具。当你需要回答关于物理学、数学、计算机科学、定量生物学、定量金融、统计学、电气工程和经济学的问题时，来自arxiv.org上的科学文章非常有用。同时还告诉模型：输入这个工具的内容应该是搜索查询。</p>
<blockquote>
<p>Use the following format:\n\n</p>
</blockquote>
<p>指导模型输出下面的内容。</p>
<blockquote>
<p>Question: the input question you must answer\n （问题：需要回答的问题）</p>
<p>Thought: you should always think about what to do\n （思考：应该总是思考下一步做什么）</p>
<p>Action: the action to take, should be one of [arxiv]\n （行动：从具体工具列表中选择行动——这里只有arxiv一个工具）</p>
<p>Action Input: the input to the action\n （行动的输入：输入工具的内容）</p>
<p>Observation: the result of the action\n… （观察：工具返回的结果）</p>
<p>(this Thought&#x2F;Action&#x2F;Action Input&#x2F;Observation can repeat N times)\n （上面 Thought&#x2F;Action&#x2F;Action Input&#x2F;Observation 的过程将重复N次）</p>
<p>Thought: I now know the final answer\n （现在我知道最终答案了）</p>
<p>Final Answer: the final answer to the original input question\n\n （原始问题的最终答案）</p>
</blockquote>
<blockquote>
<p>**Begin!**\n\n</p>
</blockquote>
<p>现在开始！</p>
<blockquote>
<p><strong>Question</strong>: ‘Chain-of-Thought Prompting Elicits Reasoning in Large Language Models’这篇论文的创新点\n</p>
</blockquote>
<p>真正的问题在此。</p>
<blockquote>
<p>Thought:”</p>
</blockquote>
<p>开始思考吧！</p>
<p>然后，我们来看看Chain的运行过程。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/6e1195d608d47fbe5b67131c1fe32357.jpg"></p>
<p>其中，代理的思考过程中的第一个返回结果如下：</p>
<blockquote>
<p>“text”: “ I need to read the paper to understand the innovation\n （思考：我需要阅读文章才能理解创新点）</p>
<p>Action: arxiv\n （行动：arxiv工具）</p>
<p>Action Input: ‘Chain-of-Thought Prompting Elicits Reasoning in Large Language Models’”, （行动的输入：论文的标题）</p>
</blockquote>
<p>因为在之前的提示中，LangChain告诉大模型，对于Arxiv工具的输入总是以搜索的形式出现，因此尽管我指明了论文的ID，Arxiv还是根据这篇论文的关键词搜索到了3篇相关论文的信息。</p>
<p>模型对这些信息进行了总结，认为信息已经完善，并给出了最终答案。</p>
<blockquote>
<p>Thought: I now know the final answer</p>
</blockquote>
<p>想法：我现在知道了最终答案。</p>
<blockquote>
<p>Final Answer: The innovation of the paper ‘Chain-of-Thought Prompting Elicits Reasoning in Large Language Models’ is the introduction of a simple method called chain of thought prompting, where a few chain of thought demonstrations are provided as exemplars in prompting, which significantly improves the ability of large language models to perform complex reasoning.”</p>
</blockquote>
<p>最终答案：这篇名为《链式思考提示促使大型语言模型进行推理》的论文的创新之处在于，引入了一种简单的方法，即链式思考提示，在提示中提供了一些链式思考的示例，这大大提高了大型语言模型执行复杂推理的能力。</p>
<h2 id="LangChain-中的工具箱一览"><a href="#LangChain-中的工具箱一览" class="headerlink" title="LangChain 中的工具箱一览"></a>LangChain 中的工具箱一览</h2><p>下面，我给你列出了目前LangChain中所支持的工具箱。每个工具箱中都有一系列工具。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/c87be0638409b278c2657a66f45aa927.jpg"></p>
<h2 id="使用-Gmail-工具箱开发个人助理"><a href="#使用-Gmail-工具箱开发个人助理" class="headerlink" title="使用 Gmail 工具箱开发个人助理"></a>使用 Gmail 工具箱开发个人助理</h2><p>刚才，你使用了arXiv工具帮助你做了一些科研工作。你当然还希望你的AI Agent能够成为你的全能自动助理，你开发出的智能应用应该能帮你检查邮件、写草稿，甚至发邮件、写文档，对吧？</p>
<p>上面这一切的一切，LangChain当然能够安排上！</p>
<ul>
<li>通过Gmail工具箱，你可以通过LangChain应用检查邮件、删除垃圾邮件，甚至让它帮你撰写邮件草稿。</li>
<li>通过Office365工具箱，你可以让LangChain应用帮你读写文档、总结文档，甚至做PPT。</li>
<li>通过GitHub工具箱，你可以指示LangChain应用来检查最新的代码，Commit Changes、Merge Branches，甚至尝试让大模型自动回答 Issues 中的问题——反正大模型解决代码问题的能力本来就更强。</li>
</ul>
<p>这些都不再是梦想。</p>
<p>下面咱们从一个最简单的应用开始。</p>
<p><strong>目标：我要让AI应用来访问我的Gmail邮件，让他每天早晨检查一次我的邮箱，看看“易速鲜花”的客服有没有给我发信息。</strong>（因为我可能正在焦急地等待他们的退款😁）</p>
<p>现在开始。</p>
<h3 id="第一步：在-Google-Cloud-中设置你的应用程序接口"><a href="#第一步：在-Google-Cloud-中设置你的应用程序接口" class="headerlink" title="第一步：在 Google Cloud 中设置你的应用程序接口"></a>第一步：在 Google Cloud 中设置你的应用程序接口</h3><p>这个步骤你要跟着Gmail API的官方配置 <a target="_blank" rel="noopener" href="https://developers.google.com/gmail/api/quickstart/python?hl=zh-cn#authorize_credentials_for_a_desktop_application">链接</a> 完成，这个和LangChain无关。蛮复杂的，你需要有点耐心。跟着流程一步步配置就好了。</p>
<p>下面是我在这个设置过程中截取的一部分图片，只是供你参考。详细配置你要follow Google的官方说明。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/8a3c72f48c231bd2d886b4d99e9f3321.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/3822d1effb90c855c133acdecea2eaab.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/96a788e8a1f7d4f32e3d23eb94cce8f3.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/0f746cfa48ba60c0fe98e657cb3yyb29.jpg"></p>
<p>下面这个OAuth同意屏幕里面的配置非常重要，你的智能代理能做什么，不能做什么，就看你怎么给权限了！</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/195ec3590bb075ecff42911f13d2f22f.jpg"></p>
<p>所有设置都完成之后，在OAuth客户段已创建这个页面，你拥有了开发密钥。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/f6829a70c320161a1002ee3380c5b1b0.jpg"></p>
<h3 id="第二步：根据密钥生成开发-Token"><a href="#第二步：根据密钥生成开发-Token" class="headerlink" title="第二步：根据密钥生成开发 Token"></a>第二步：根据密钥生成开发 Token</h3><p>在这一步之前，你可能需要安装一些相关的包。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">pip install --upgrade google-api-python-client
pip install --upgrade google-auth-oauthlib
pip install --upgrade google-auth-httplib2
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>然后，把密钥下载下来，保存为credentials.json。</p>
<p>运行下面的代码，生成token.json。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">from __future__ import print_function

import os.path

from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# If modifying these scopes, delete the file token.json.
SCOPES = ['https://www.googleapis.com/auth/gmail.readonly']

def main():
    """Shows basic usage of the Gmail API.
    Lists the user's Gmail labels.
    """
    creds = None
    # The file token.json stores the user's access and refresh tokens, and is
    # created automatically when the authorization flow completes for the first
    # time.
    if os.path.exists('token.json'):
        creds = Credentials.from_authorized_user_file('token.json', SCOPES)
    # If there are no (valid) credentials available, let the user log in.
    if not creds or not creds.valid:
        if creds and creds.expired and creds.refresh_token:
            creds.refresh(Request())
        else:
            flow = InstalledAppFlow.from_client_secrets_file(
                'credentials.json', SCOPES)
            creds = flow.run_local_server(port=8088)
        # Save the credentials for the next run
        with open('token.json', 'w') as token:
            token.write(creds.to_json())

    try:
        # Call the Gmail API
        service = build('gmail', 'v1', credentials=creds)
        results = service.users().labels().list(userId='me').execute()
        labels = results.get('labels', [])

        if not labels:
            print('No labels found.')
            return
        print('Labels:')
        for label in labels:
            print(label['name'])

    except HttpError as error:
        # TODO(developer) - Handle errors from gmail API.
        print(f'An error occurred: &#123;error&#125;')

if __name__ == '__main__':
    main()
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这是Google API网站提供的标准示例代码，里面给了读取权限（gmail.readonly）的Token，如果你要编写邮件，甚至发送邮件，需要根据需求来调整权限。更多细节可以参阅Google API的 <a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/apis?hl=zh-cn">文档</a>。</p>
<p>这个程序会生成一个token.json文件，是有相关权限的开发令牌。这个文件在LangChain应用中需要和密钥一起使用。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/541c541b377063b49d74ddc53f41d578.jpg"></p>
<p>把密钥和Token文件都放在程序的同一个目录中，你就可以开始开发应用程序了。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/f23144b35b44fef8d900d0d50c9da6b4.jpg"></p>
<h3 id="第三步：用-LangChain-框架开发-Gmail-App"><a href="#第三步：用-LangChain-框架开发-Gmail-App" class="headerlink" title="第三步：用 LangChain 框架开发 Gmail App"></a>第三步：用 LangChain 框架开发 Gmail App</h3><p>这段代码的核心目的是连接到Gmail API，查询用户的邮件，并通过LangChain的Agent框架智能化地调用API（用语言而不是具体API），与邮件进行互动。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 设置OpenAI API的密钥
import os
os.environ["OPENAI_API_KEY"] = 'Your Key'

# 导入与Gmail交互所需的工具包
from langchain.agents.agent_toolkits import GmailToolkit

# 初始化Gmail工具包
toolkit = GmailToolkit()

# 从gmail工具中导入一些有用的功能
from langchain.tools.gmail.utils import build_resource_service, get_gmail_credentials

# 获取Gmail API的凭证，并指定相关的权限范围
credentials = get_gmail_credentials(
    token_file="token.json",  # Token文件路径
    scopes=["https://mail.google.com/"],  # 具有完全的邮件访问权限
    client_secrets_file="credentials.json",  # 客户端的秘密文件路径
)
# 使用凭证构建API资源服务
api_resource = build_resource_service(credentials=credentials)
toolkit = GmailToolkit(api_resource=api_resource)

# 获取工具
tools = toolkit.get_tools()
print(tools)

# 导入与聊天模型相关的包
from langchain.chat_models import ChatOpenAI
from langchain.agents import initialize_agent, AgentType

# 初始化聊天模型
llm = ChatOpenAI(temperature=0, model='gpt-4')

# 通过指定的工具和聊天模型初始化agent
agent = initialize_agent(
    tools=toolkit.get_tools(),
    llm=llm,
    agent=AgentType.STRUCTURED_CHAT_ZERO_SHOT_REACT_DESCRIPTION,
)

# 使用agent运行一些查询或指令
result = agent.run(
    "今天易速鲜花客服给我发邮件了么？最新的邮件是谁发给我的？"
)

# 打印结果
print(result)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>代码的核心部分主要是连接到Gmail API，获取用户的邮件数据，并通过特定的 Agent 查询这些数据。</p>
<p>你的请求是查询今天是否收到了来自“易速鲜花客服”的邮件，以及最新邮件的发送者是谁。 <strong>这个请求是模糊的，是自然语言格式，具体调用什么API，由Agent、Tool也就是Gmail API它俩商量着来。</strong> 这与我们之前所进行的清晰的、具体API调用式的应用开发迥然不同。</p>
<p>第一次运行程序，会进行一些确认，并让我Login我的Gmail。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/0e2a7df295caa50512552e05ea3def37.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/3208ff117674ebf3f08eac6118393e51.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/0cc81560c4bc412104b5144a474c5530.jpg"></p>
<p>之后，我就得到了智能助手的回答！</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/455f8cb0138cd3860869e5eee74f8ecf.jpg"></p>
<p>她说： <strong>主人，看起来你没有收到“易速鲜花”的邮件耶，还需要我帮你做些什么吗？</strong> 真的很贴心，这样的话，我每天早晨就不需要自己去检查邮件啦！</p>
<p>后来，我又问她，那么谁给我发来了新邮件呢？</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/c95a8e75cdc78a7da4960c8f2yyf8be4.jpg"></p>
<p>她告诉我说，Medium - Programing 给我发了一篇 VS code 的 10 个 tips 的文章，还有Kubernetes的点子啥的。</p>
<p>嗯，这是我订阅的内容。下一步，我还可以让她针对这些内容给我总结总结！这也是她的强项！</p>
<h2 id="总结时刻"><a href="#总结时刻" class="headerlink" title="总结时刻"></a>总结时刻</h2><p>学到现在，你应该对LangChain 的核心价值有了更深的感悟吧。它的价值，在于它将模型运行和交互的复杂性进行了封装和抽象化，为开发者提供了一个更简单、更直观的接口来利用大模型。</p>
<ul>
<li><p><strong>集成多模型和多策略：</strong> LangChain 提供了一种方法，使得多个模型或策略能够在一个统一的框架下工作。例如，arXiv 是一个单独的工具，它负责处理特定的任务。这种工具可以与其他工具（例如用于处理自然语言查询或者数据库查询的工具）一起作为一个集成的系统存在。这样，你可以轻松地创建一个系统，该系统可以处理多种类型的输入并执行多种任务，而不必为每个任务单独写代码。</p>
</li>
<li><p><strong>更易于交互和维护：</strong> 通过 LangChain，你可以更方便地管理和维护你的工具和模型。LangChain 提供的工具和代理（Agent）抽象使得开发者可以将关注点从底层实现细节转向实现应用的高层逻辑。而且，LangChain封装了像模型的加载、输入输出的处理、工具的调度等底层任务，使得开发者能够更专注于如何组合这些工具以解决实际问题。</p>
</li>
<li><p><strong>适应性：</strong> LangChain 提供的架构允许你轻松地添加新的工具或模型，或者替换现有的工具或模型。这种灵活性使得你的系统可以很容易地适应新的需求或改变。</p>
</li>
<li><p><strong>可解释性：</strong> LangChain 还提供了对模型决策的可解释性。在你的示例中，LangChain 提供的对话历史和工具选择的记录可以帮助理解系统做出某些决策的原因。</p>
</li>
</ul>
<p>总的来说，尽管直接调用模型可能对于单一任务或简单应用来说足够了，但是当你需要处理更复杂的场景，例如需要协调多个模型或工具，或者需要处理多种类型的输入时，使用像 LangChain 这样的框架可以大大简化你的工作。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li><p>上面Gmail的示例中我只是展示了邮件读取功能，你能否让你的AI助理帮你写邮件的草稿甚至发送邮件？</p>
</li>
<li><p>你可否尝试使用GitHub工具开发一些App来自动完成一部分GitHub任务，比如查看Issues、Merge Branches之类的事儿。</p>
</li>
</ol>
<p>提示：参考此 <a target="_blank" rel="noopener" href="https://docs.github.com/en/apps/creating-github-apps/registering-a-github-app/registering-a-github-app">链接</a> 创建 GitHub App，以及LangChain的 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/toolkits/github">参考文档</a>。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/1bc0dcd6e05133f934ed926cdcc9eb2e.jpg"></p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/e037cf6460826e189811ea2af4bb96ea.jpg"></p>
<p>期待在留言区看到你的分享，如果你觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ol>
<li>文档：LangChain中集成的所有 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/tools/">工具</a></li>
<li>文档：LangChain中集成的所有 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/integrations/toolkits/">工具箱</a></li>
<li>文档：Google Cloud <a target="_blank" rel="noopener" href="https://cloud.google.com/compute/docs/apis?hl=zh-cn">API</a></li>
<li>文档：Github REST <a target="_blank" rel="noopener" href="https://support.github.com/features/rest-api">API</a></li>
</ol>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#14%EF%BD%9C%E5%B7%A5%E5%85%B7%E5%92%8C%E5%B7%A5%E5%85%B7%E7%AE%B1%EF%BC%9ALangChain%E4%B8%AD%E7%9A%84Tool%E5%92%8CToolkits%E4%B8%80%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">14｜工具和工具箱：LangChain中的Tool和Toolkits一览</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%98%AF%E4%BB%A3%E7%90%86%E7%9A%84%E6%AD%A6%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">工具是代理的武器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD%E5%B7%A5%E5%85%B7"><span class="toc-number">1.2.</span> <span class="toc-text">如何加载工具</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LangChain-%E6%94%AF%E6%8C%81%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%80%E8%A7%88"><span class="toc-number">1.3.</span> <span class="toc-text">LangChain 支持的工具一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-arXiv-%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91%E7%A7%91%E7%A0%94%E5%8A%A9%E7%90%86"><span class="toc-number">1.4.</span> <span class="toc-text">使用 arXiv 工具开发科研助理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LangChain-%E4%B8%AD%E7%9A%84%E5%B7%A5%E5%85%B7%E7%AE%B1%E4%B8%80%E8%A7%88"><span class="toc-number">1.5.</span> <span class="toc-text">LangChain 中的工具箱一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Gmail-%E5%B7%A5%E5%85%B7%E7%AE%B1%E5%BC%80%E5%8F%91%E4%B8%AA%E4%BA%BA%E5%8A%A9%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">使用 Gmail 工具箱开发个人助理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%9C%A8-Google-Cloud-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E4%BD%A0%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.6.1.</span> <span class="toc-text">第一步：在 Google Cloud 中设置你的应用程序接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E6%A0%B9%E6%8D%AE%E5%AF%86%E9%92%A5%E7%94%9F%E6%88%90%E5%BC%80%E5%8F%91-Token"><span class="toc-number">1.6.2.</span> <span class="toc-text">第二步：根据密钥生成开发 Token</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E7%94%A8-LangChain-%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91-Gmail-App"><span class="toc-number">1.6.3.</span> <span class="toc-text">第三步：用 LangChain 框架开发 Gmail App</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%97%B6%E5%88%BB"><span class="toc-number">1.7.</span> <span class="toc-text">总结时刻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.8.</span> <span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="toc-number">1.9.</span> <span class="toc-text">延伸阅读</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2023 By 码农张三</div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>