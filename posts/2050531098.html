<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>07｜输出解析：用OutputParser生成鲜花推荐列表 | geekbang</title><meta name="author" content="码农张三"><meta name="copyright" content="码农张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="07｜输出解析：用OutputParser生成鲜花推荐列表你好，我是黄佳，欢迎来到LangChain实战课！ 首先请你回忆一下 第4课 中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个CSV文件中。为了实现这个目标，程序调用了OpenAI模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。 今天我要带着你深入研究一下LangChain中的输出解析器，并用一个">
<meta property="og:type" content="article">
<meta property="og:title" content="07｜输出解析：用OutputParser生成鲜花推荐列表">
<meta property="og:url" content="https://zhuansun.github.io/geekbang/posts/2050531098.html">
<meta property="og:site_name" content="geekbang">
<meta property="og:description" content="07｜输出解析：用OutputParser生成鲜花推荐列表你好，我是黄佳，欢迎来到LangChain实战课！ 首先请你回忆一下 第4课 中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个CSV文件中。为了实现这个目标，程序调用了OpenAI模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。 今天我要带着你深入研究一下LangChain中的输出解析器，并用一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg">
<meta property="article:published_time" content="2023-10-20T09:48:40.000Z">
<meta property="article:modified_time" content="2024-03-21T11:04:50.534Z">
<meta property="article:author" content="码农张三">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/geekbang/posts/2050531098"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '07｜输出解析：用OutputParser生成鲜花推荐列表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-21 11:04:50'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geekbang" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/653470a0c458853aef5813f1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1345</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geekbang</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">07｜输出解析：用OutputParser生成鲜花推荐列表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-10-20T09:48:40.000Z" title="发表于 2023-10-20 09:48:40">2023-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LangChain%E5%AE%9E%E6%88%98%E8%AF%BE/">LangChain实战课</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="07｜输出解析：用OutputParser生成鲜花推荐列表"><a href="#07｜输出解析：用OutputParser生成鲜花推荐列表" class="headerlink" title="07｜输出解析：用OutputParser生成鲜花推荐列表"></a>07｜输出解析：用OutputParser生成鲜花推荐列表</h1><p>你好，我是黄佳，欢迎来到LangChain实战课！</p>
<p>首先请你回忆一下 <a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/700699">第4课</a> 中我们学了什么: 为一些花和价格生成吸引人的描述，并将这些描述和原因存储到一个CSV文件中。为了实现这个目标，程序调用了OpenAI模型，并利用了结构化输出解析器，以及一些数据处理和存储的工具。</p>
<p>今天我要带着你深入研究一下LangChain中的输出解析器，并用一个新的解析器——Pydantic 解析器来重构第4课中的程序。这节课也是模型I&#x2F;O框架的最后一讲。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/6215fdd31373523a46bb02f86283522d.jpg"></p>
<p>下面先来看看LangChain中的输出解析器究竟是什么，有哪些种类。</p>
<h2 id="LangChain-中的输出解析器"><a href="#LangChain-中的输出解析器" class="headerlink" title="LangChain 中的输出解析器"></a>LangChain 中的输出解析器</h2><p>语言模型输出的是文本，这是给人类阅读的。但很多时候，你可能想要获得的是程序能够处理的结构化信息。这就是输出解析器发挥作用的地方。</p>
<p>输出解析器是 <strong>一种专用于处理和构建语言模型响应的类</strong>。一个基本的输出解析器类通常需要实现两个核心方法。</p>
<ul>
<li>get_format_instructions：这个方法需要返回一个字符串，用于指导如何格式化语言模型的输出，告诉它应该如何组织并构建它的回答。</li>
<li>parse：这个方法接收一个字符串（也就是语言模型的输出）并将其解析为特定的数据结构或格式。这一步通常用于确保模型的输出符合我们的预期，并且能够以我们需要的形式进行后续处理。</li>
</ul>
<p>还有一个可选的方法。</p>
<ul>
<li>parse_with_prompt：这个方法接收一个字符串（也就是语言模型的输出）和一个提示（用于生成这个输出的提示），并将其解析为特定的数据结构。这样，你可以根据原始提示来修正或重新解析模型的输出，确保输出的信息更加准确和贴合要求。</li>
</ul>
<p>下面是一个基于上述描述的简单伪代码示例：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">OutputParser</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">get_format_instructions</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 返回一个字符串，指导如何格式化模型的输出</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">parse</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> model_output<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 解析模型的输出，转换为某种数据结构或格式</span>
        <span class="token keyword">pass</span>

    <span class="token keyword">def</span> <span class="token function">parse_with_prompt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> model_output<span class="token punctuation">,</span> prompt<span class="token punctuation">)</span><span class="token punctuation">:</span>
        <span class="token comment"># 基于原始提示解析模型的输出，转换为某种数据结构或格式</span>
        <span class="token keyword">pass</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在LangChain中，通过实现get_format_instructions、parse 和 parse_with_prompt 这些方法，针对不同的使用场景和目标，设计了各种输出解析器。让我们来逐一认识一下。</p>
<ol>
<li>列表解析器（List Parser）：这个解析器用于处理模型生成的输出，当需要模型的输出是一个列表的时候使用。例如，如果你询问模型“列出所有鲜花的库存”，模型的回答应该是一个列表。</li>
<li>日期时间解析器（Datetime Parser）：这个解析器用于处理日期和时间相关的输出，确保模型的输出是正确的日期或时间格式。</li>
<li>枚举解析器（Enum Parser）：这个解析器用于处理预定义的一组值，当模型的输出应该是这组预定义值之一时使用。例如，如果你定义了一个问题的答案只能是“是”或“否”，那么枚举解析器可以确保模型的回答是这两个选项之一。</li>
<li>结构化输出解析器（Structured Output Parser）：这个解析器用于处理复杂的、结构化的输出。如果你的应用需要模型生成具有特定结构的复杂回答（例如一份报告、一篇文章等），那么可以使用结构化输出解析器来实现。</li>
<li>Pydantic（JSON）解析器：这个解析器用于处理模型的输出，当模型的输出应该是一个符合特定格式的JSON对象时使用。它使用Pydantic库，这是一个数据验证库，可以用于构建复杂的数据模型，并确保模型的输出符合预期的数据模型。</li>
<li>自动修复解析器（Auto-Fixing Parser）：这个解析器可以自动修复某些常见的模型输出错误。例如，如果模型的输出应该是一段文本，但是模型返回了一段包含语法或拼写错误的文本，自动修复解析器可以自动纠正这些错误。</li>
<li>重试解析器（RetryWithErrorOutputParser）：这个解析器用于在模型的初次输出不符合预期时，尝试修复或重新生成新的输出。例如，如果模型的输出应该是一个日期，但是模型返回了一个字符串，那么重试解析器可以重新提示模型生成正确的日期格式。</li>
</ol>
<p>上面的各种解析器中，前三种很容易理解，而结构化输出解析器你已经用过了。所以接下来我们重点讲一讲Pydantic（JSON）解析器、自动修复解析器和重试解析器。</p>
<h2 id="Pydantic（JSON）解析器实战"><a href="#Pydantic（JSON）解析器实战" class="headerlink" title="Pydantic（JSON）解析器实战"></a>Pydantic（JSON）解析器实战</h2><p>Pydantic (JSON) 解析器应该是最常用也是最重要的解析器，我带着你用它来重构鲜花文案生成程序。</p>
<blockquote>
<p>Pydantic 是一个 Python 数据验证和设置管理库，主要基于 Python 类型提示。尽管它不是专为 JSON 设计的，但由于 JSON 是现代 Web 应用和 API 交互中的常见数据格式，Pydantic 在处理和验证 JSON 数据时特别有用。</p>
</blockquote>
<h3 id="第一步：创建模型实例"><a href="#第一步：创建模型实例" class="headerlink" title="第一步：创建模型实例"></a>第一步：创建模型实例</h3><p>先通过环境变量设置OpenAI API密钥，然后使用LangChain库创建了一个OpenAI的模型实例。这里我们仍然选择了text-davinci-003作为大语言模型。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ------Part 1</span>
<span class="token comment"># 设置OpenAI API密钥</span>
<span class="token keyword">import</span> os
os<span class="token punctuation">.</span>environ<span class="token punctuation">[</span><span class="token string">"OPENAI_API_KEY"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'你的OpenAI API Key'</span>

<span class="token comment"># 创建模型实例</span>
<span class="token keyword">from</span> langchain <span class="token keyword">import</span> OpenAI
model <span class="token operator">=</span> OpenAI<span class="token punctuation">(</span>model_name<span class="token operator">=</span><span class="token string">'text-davinci-003'</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="第二步：定义输出数据的格式"><a href="#第二步：定义输出数据的格式" class="headerlink" title="第二步：定义输出数据的格式"></a>第二步：定义输出数据的格式</h3><p>先创建了一个空的DataFrame，用于存储从模型生成的描述。接下来，通过一个名为FlowerDescription的Pydantic BaseModel类，定义了期望的数据格式（也就是数据的结构）。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ------Part 2</span>
<span class="token comment"># 创建一个空的DataFrame用于存储结果</span>
<span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
df <span class="token operator">=</span> pd<span class="token punctuation">.</span>DataFrame<span class="token punctuation">(</span>columns<span class="token operator">=</span><span class="token punctuation">[</span><span class="token string">"flower_type"</span><span class="token punctuation">,</span> <span class="token string">"price"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">,</span> <span class="token string">"reason"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment"># 数据准备</span>
flowers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"玫瑰"</span><span class="token punctuation">,</span> <span class="token string">"百合"</span><span class="token punctuation">,</span> <span class="token string">"康乃馨"</span><span class="token punctuation">]</span>
prices <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"50"</span><span class="token punctuation">,</span> <span class="token string">"30"</span><span class="token punctuation">,</span> <span class="token string">"20"</span><span class="token punctuation">]</span>

<span class="token comment"># 定义我们想要接收的数据格式</span>
<span class="token keyword">from</span> pydantic <span class="token keyword">import</span> BaseModel<span class="token punctuation">,</span> Field
<span class="token keyword">class</span> <span class="token class-name">FlowerDescription</span><span class="token punctuation">(</span>BaseModel<span class="token punctuation">)</span><span class="token punctuation">:</span>
    flower_type<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> Field<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"鲜花的种类"</span><span class="token punctuation">)</span>
    price<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> Field<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"鲜花的价格"</span><span class="token punctuation">)</span>
    description<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> Field<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"鲜花的描述文案"</span><span class="token punctuation">)</span>
    reason<span class="token punctuation">:</span> <span class="token builtin">str</span> <span class="token operator">=</span> Field<span class="token punctuation">(</span>description<span class="token operator">=</span><span class="token string">"为什么要这样写这个文案"</span><span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在这里我们用到了负责数据格式验证的Pydantic库来创建带有类型注解的类FlowerDescription，它可以自动验证输入数据，确保输入数据符合你指定的类型和其他验证条件。</p>
<p>Pydantic有这样几个特点。</p>
<ol>
<li>数据验证：当你向Pydantic类赋值时，它会自动进行数据验证。例如，如果你创建了一个字段需要是整数，但试图向它赋予一个字符串，Pydantic会引发异常。</li>
<li>数据转换：Pydantic不仅进行数据验证，还可以进行数据转换。例如，如果你有一个需要整数的字段，但你提供了一个可以转换为整数的字符串，如 <code>&quot;42&quot;</code>，Pydantic会自动将这个字符串转换为整数42。</li>
<li>易于使用：创建一个Pydantic类就像定义一个普通的Python类一样简单。只需要使用Python的类型注解功能，即可在类定义中指定每个字段的类型。</li>
<li>JSON支持：Pydantic类可以很容易地从JSON数据创建，并可以将类的数据转换为JSON格式。</li>
</ol>
<p>下面，我们基于这个Pydantic数据格式类来创建LangChain的输出解析器。</p>
<h3 id="第三步：创建输出解析器"><a href="#第三步：创建输出解析器" class="headerlink" title="第三步：创建输出解析器"></a>第三步：创建输出解析器</h3><p>在这一步中，我们创建输出解析器并获取输出格式指示。先使用LangChain库中的PydanticOutputParser创建了输出解析器，该解析器将用于解析模型的输出，以确保其符合FlowerDescription的格式。然后，使用解析器的get_format_instructions方法获取了输出格式的指示。</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># ------Part 3</span>
<span class="token comment"># 创建输出解析器</span>
<span class="token keyword">from</span> langchain<span class="token punctuation">.</span>output_parsers <span class="token keyword">import</span> PydanticOutputParser
output_parser <span class="token operator">=</span> PydanticOutputParser<span class="token punctuation">(</span>pydantic_object<span class="token operator">=</span>FlowerDescription<span class="token punctuation">)</span>

<span class="token comment"># 获取输出格式指示</span>
format_instructions <span class="token operator">=</span> output_parser<span class="token punctuation">.</span>get_format_instructions<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 打印提示</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"输出格式："</span><span class="token punctuation">,</span>format_instructions<span class="token punctuation">)</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>程序输出如下：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">输出格式： The output should be formatted <span class="token keyword">as</span> a JSON instance that conforms to the JSON schema below<span class="token punctuation">.</span>

As an example<span class="token punctuation">,</span> <span class="token keyword">for</span> the schema <span class="token punctuation">&#123;</span><span class="token string">"properties"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Foo"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"a list of strings"</span><span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"array"</span><span class="token punctuation">,</span> <span class="token string">"items"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"string"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"required"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
the <span class="token builtin">object</span> <span class="token punctuation">&#123;</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span> <span class="token keyword">is</span> a well<span class="token operator">-</span>formatted instance of the schema<span class="token punctuation">.</span> The <span class="token builtin">object</span> <span class="token punctuation">&#123;</span><span class="token string">"properties"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"foo"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"bar"</span><span class="token punctuation">,</span> <span class="token string">"baz"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> <span class="token keyword">is</span> <span class="token keyword">not</span> well<span class="token operator">-</span>formatted<span class="token punctuation">.</span>

Here <span class="token keyword">is</span> the output schema<span class="token punctuation">:</span>

<span class="token punctuation">&#123;</span><span class="token string">"properties"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"flower_type"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Flower Type"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"\u9c9c\u82b1\u7684\u79cd\u7c7b"</span><span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"string"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"price"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Price"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"\u9c9c\u82b1\u7684\u4ef7\u683c"</span><span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"integer"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Description"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"\u9c9c\u82b1\u7684\u63cf\u8ff0\u6587\u6848"</span><span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"string"</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"reason"</span><span class="token punctuation">:</span> <span class="token punctuation">&#123;</span><span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"Reason"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">:</span> <span class="token string">"\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u5199\u8fd9\u4e2a\u6587\u6848"</span><span class="token punctuation">,</span> <span class="token string">"type"</span><span class="token punctuation">:</span> <span class="token string">"string"</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token string">"required"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"flower_type"</span><span class="token punctuation">,</span> <span class="token string">"price"</span><span class="token punctuation">,</span> <span class="token string">"description"</span><span class="token punctuation">,</span> <span class="token string">"reason"</span><span class="token punctuation">]</span><span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>上面这个输出，这部分是通过output_parser.get_format_instructions()方法生成的，这是Pydantic (JSON) 解析器的核心价值，值得你好好研究研究。同时它也算得上是一个很清晰的提示模板，能够为模型提供良好的指导，描述了模型输出应该符合的格式。（其中description中的中文被转成了UTF-8编码。）</p>
<p>它指示模型输出JSON Schema的形式，定义了一个有效的输出应该包含哪些字段，以及这些字段的数据类型。例如，它指定了 <code>&quot;flower_type&quot;</code> 字段应该是字符串类型， <code>&quot;price&quot;</code> 字段应该是整数类型。这个指示中还提供了一个例子，说明了什么是一个格式良好的输出。</p>
<p>下面，我们会把这个内容也传输到模型的提示中， <strong>让输入模型的提示和输出解析器的要求相互吻合，前后就呼应得上</strong>。</p>
<h3 id="第四步：创建提示模板"><a href="#第四步：创建提示模板" class="headerlink" title="第四步：创建提示模板"></a>第四步：创建提示模板</h3><p>我们定义了一个提示模板，该模板将用于为模型生成输入提示。模板中包含了你需要模型填充的变量（如价格和花的种类），以及之前获取的输出格式指示。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># ------Part 4
# 创建提示模板
from langchain import PromptTemplate
prompt_template = """您是一位专业的鲜花店文案撰写员。
对于售价为 &#123;price&#125; 元的 &#123;flower&#125; ，您能提供一个吸引人的简短中文描述吗？
&#123;format_instructions&#125;"""

# 根据模板创建提示，同时在提示中加入输出解析器的说明
prompt = PromptTemplate.from_template(prompt_template,
       partial_variables=&#123;"format_instructions": format_instructions&#125;)

# 打印提示
print("提示：", prompt)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>输出：</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">提示：
input_variables=['flower', 'price']

output_parser=None

partial_variables=&#123;'format_instructions': 'The output should be formatted as a JSON instance that conforms to the JSON schema below.\n\n
As an example, for the schema &#123;
"properties": &#123;"foo": &#123;"title": "Foo", "description": "a list of strings", "type": "array", "items": &#123;"type": "string"&#125;&#125;&#125;,
"required": ["foo"]&#125;&#125;\n
the object &#123;"foo": ["bar", "baz"]&#125; is a well-formatted instance of the schema.
The object &#123;"properties": &#123;"foo": ["bar", "baz"]&#125;&#125; is not well-formatted.\n\n
Here is the output schema:\n```\n
&#123;"properties": &#123;
"flower_type": &#123;"title": "Flower Type", "description": "\\u9c9c\\u82b1\\u7684\\u79cd\\u7c7b", "type": "string"&#125;,
"price": &#123;"title": "Price", "description": "\\u9c9c\\u82b1\\u7684\\u4ef7\\u683c", "type": "integer"&#125;,
"description": &#123;"title": "Description", "description": "\\u9c9c\\u82b1\\u7684\\u63cf\\u8ff0\\u6587\\u6848", "type": "string"&#125;,
"reason": &#123;"title": "Reason", "description": "\\u4e3a\\u4ec0\\u4e48\\u8981\\u8fd9\\u6837\\u5199\\u8fd9\\u4e2a\\u6587\\u6848", "type": "string"&#125;&#125;,
"required": ["flower_type", "price", "description", "reason"]&#125;\n```'&#125;

template='您是一位专业的鲜花店文案撰写员。
\n对于售价为 &#123;price&#125; 元的 &#123;flower&#125; ，您能提供一个吸引人的简短中文描述吗？\n
&#123;format_instructions&#125;'

template_format='f-string'

validate_template=True
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这就是包含了format_instructions信息的提示模板。</p>
<ol>
<li><code>input_variables=[&#39;flower&#39;, &#39;price&#39;]</code>：这是一个包含你想要在模板中使用的输入变量的列表。我们在模板中使用了 <code>&#39;flower&#39;</code> 和 <code>&#39;price&#39;</code> 两个变量，后面我们会用具体的值（如玫瑰、20元）来替换这两个变量。</li>
<li><code>output_parser=None</code>：这是你可以选择在模板中使用的一个输出解析器。在此例中，我们并没有选择在模板中使用输出解析器，而是在模型外部进行输出解析，所以这里是 <code>None</code>。</li>
<li><code>partial_variables</code>：包含了你想要在模板中使用，但在生成模板时无法立即提供的变量。在这里，我们通过 <code>&#39;format_instructions&#39;</code> 传入输出格式的详细说明。</li>
<li><code>template</code>：这是模板字符串本身。它包含了你想要模型生成的文本的结构。在此例中，模板字符串是你询问鲜花描述的问题，以及关于输出格式的说明。</li>
<li><code>template_format=&#39;f-string&#39;</code>：这是一个表示模板字符串格式的选项。此处是f-string格式。</li>
<li><code>validate_template=True</code>：表示是否在创建模板时检查模板的有效性。这里选择了在创建模板时进行检查，以确保模板是有效的。</li>
</ol>
<p>总的来说，这个提示模板是一个用于生成模型输入的工具。你可以在模板中定义需要的输入变量，以及模板字符串的格式和结构，然后使用这个模板来为每种鲜花生成一个描述。</p>
<p>后面，我们还要把实际的信息，循环传入提示模板，生成一个个的具体提示。下面让我们继续。</p>
<h3 id="第五步：生成提示，传入模型并解析输出"><a href="#第五步：生成提示，传入模型并解析输出" class="headerlink" title="第五步：生成提示，传入模型并解析输出"></a>第五步：生成提示，传入模型并解析输出</h3><p>这部分是程序的主体，我们循环来处理所有的花和它们的价格。对于每种花，都根据提示模板创建了输入，然后获取模型的输出。然后使用之前创建的解析器来解析这个输出，并将解析后的输出添加到DataFrame中。最后，你打印出了所有的结果，并且可以选择将其保存到CSV文件中。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># ------Part 5
for flower, price in zip(flowers, prices):
    # 根据提示准备模型的输入
    input = prompt.format(flower=flower, price=price)
    # 打印提示
    print("提示：", input)

    # 获取模型的输出
    output = model(input)

    # 解析模型的输出
    parsed_output = output_parser.parse(output)
    parsed_output_dict = parsed_output.dict()  # 将Pydantic格式转换为字典

    # 将解析后的输出添加到DataFrame中
    df.loc[len(df)] = parsed_output.dict()

# 打印字典
print("输出的数据：", df.to_dict(orient='records'))
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这一步中，你使用你的模型和输入提示（由鲜花种类和价格组成）生成了一个具体鲜花的文案需求（同时带有格式描述），然后传递给大模型，也就是说，提示模板中的 flower 和 price，此时都被具体的花取代了，而且模板中的 {format_instructions}，也被替换成了 JSON Schema 中指明的格式信息。</p>
<p>具体来说，输出的一个提示是这样的：</p>
<blockquote>
<p><strong>提示</strong>： 您是一位专业的鲜花店文案撰写员。</p>
<p>对于售价为 20 元的 康乃馨 ，您能提供一个吸引人的简短中文描述吗？</p>
<p>The output should be formatted as a JSON instance that conforms to the JSON schema below.</p>
<p>As an example, for the schema {“properties”: {“foo”: {“title”: “Foo”, “description”: “a list of strings”, “type”: “array”, “items”: {“type”: “string”}}}, “required”: [“foo”]}}</p>
<p>the object {“foo”: [“bar”, “baz”]} is a well-formatted instance of the schema. The object {“properties”: {“foo”: [“bar”, “baz”]}} is not well-formatted.</p>
<p>Here is the output schema:</p>
<pre class="line-numbers language-none"><code class="language-none">&#123;&quot;properties&quot;: &#123;&quot;flower_type&quot;: &#123;&quot;title&quot;: &quot;Flower Type&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u79cd\u7c7b&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;price&quot;: &#123;&quot;title&quot;: &quot;Price&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u4ef7\u683c&quot;, &quot;type&quot;: &quot;integer&quot;&#125;, &quot;description&quot;: &#123;&quot;title&quot;: &quot;Description&quot;, &quot;description&quot;: &quot;\u9c9c\u82b1\u7684\u63cf\u8ff0\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;, &quot;reason&quot;: &#123;&quot;title&quot;: &quot;Reason&quot;, &quot;description&quot;: &quot;\u4e3a\u4ec0\u4e48\u8981\u8fd9\u6837\u5199\u8fd9\u4e2a\u6587\u6848&quot;, &quot;type&quot;: &quot;string&quot;&#125;&#125;, &quot;required&quot;: [&quot;flower_type&quot;, &quot;price&quot;, &quot;description&quot;, &quot;reason&quot;]&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</blockquote>
<p>下面，程序解析模型的输出。在这一步中，你使用你之前定义的输出解析器（output_parser）将模型的输出解析成了一个FlowerDescription的实例。FlowerDescription是你之前定义的一个Pydantic类，它包含了鲜花的类型、价格、描述以及描述的理由。</p>
<p>然后，将解析后的输出添加到DataFrame中。在这一步中，你将解析后的输出（即FlowerDescription实例）转换为一个字典，并将这个字典添加到你的DataFrame中。这个DataFrame是你用来存储所有鲜花描述的。</p>
<p>模型的最后输出如下：</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">输出的数据：
[&#123;'flower_type': 'Rose', 'price': 50, 'description': '玫瑰是最浪漫的花，它具有柔和的粉红色，有着浓浓的爱意，价格实惠，50元就可以拥有一束玫瑰。', 'reason': '玫瑰代表着爱情，是最浪漫的礼物，以实惠的价格，可以让您尽情体验爱的浪漫。'&#125;,
&#123;'flower_type': '百合', 'price': 30, 'description': '这支百合，柔美的花蕾，在你的手中摇曳，仿佛在与你深情的交谈', 'reason': '营造浪漫氛围'&#125;,
&#123;'flower_type': 'Carnation', 'price': 20, 'description': '艳丽缤纷的康乃馨，带给你温馨、浪漫的气氛，是最佳的礼物选择！', 'reason': '康乃馨是一种颜色鲜艳、芬芳淡雅、具有浪漫寓意的鲜花，非常适合作为礼物，而且20元的价格比较实惠。'&#125;]
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>因此，Pydantic的优点就是容易解析，而解析之后的字典格式的列表在进行数据分析、处理和存储时非常方便。每个字典代表一条记录，它的键（ 即 <code>&quot;flower_type&quot;</code>、 <code>&quot;price&quot;</code>、 <code>&quot;description&quot;</code> 和 <code>&quot;reason&quot;</code>）是字段名称，对应的值是这个字段的内容。这样一来，每个字段都对应一列，每个字典就是一行，适合以DataFrame的形式来表示和处理。</p>
<h2 id="自动修复解析器（OutputFixingParser）实战"><a href="#自动修复解析器（OutputFixingParser）实战" class="headerlink" title="自动修复解析器（OutputFixingParser）实战"></a>自动修复解析器（OutputFixingParser）实战</h2><p>下面咱们来看看如何使用自动修复解析器。</p>
<p>首先，让我们来设计一个解析时出现的错误。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 导入所需要的库和模块
from langchain.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field
from typing import List

# 使用Pydantic创建一个数据格式，表示花
class Flower(BaseModel):
    name: str = Field(description="name of a flower")
    colors: List[str] = Field(description="the colors of this flower")
# 定义一个用于获取某种花的颜色列表的查询
flower_query = "Generate the charaters for a random flower."

# 定义一个格式不正确的输出
misformatted = "&#123;'name': '康乃馨', 'colors': ['粉红色','白色','红色','紫色','黄色']&#125;"

# 创建一个用于解析输出的Pydantic解析器，此处希望解析为Flower格式
parser = PydanticOutputParser(pydantic_object=Flower)
# 使用Pydantic解析器解析不正确的输出
parser.parse(misformatted)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码如果运行，会出现错误。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">langchain.schema.output_parser.OutputParserException: Failed to parse Flower from completion &#123;'name': '康乃馨', 'colors': ['粉红色','白色']&#125;. Got: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这个错误消息来自Python的内建JSON解析器发现我们输入的JSON格式不正确。程序尝试用PydanticOutputParser来解析JSON字符串时，Python期望属性名称被双引号包围，但在给定的JSON字符串中是单引号。</p>
<p>当这个错误被触发后，程序进一步引发了一个自定义异常：OutputParserException，它提供了更多关于错误的上下文。这个自定义异常的消息表示在尝试解析flower对象时遇到了问题。</p>
<p>刚才说了，问题在于misformatted字符串的内容：</p>
<p><code>&quot;&#123;&#39;name&#39;: &#39;康乃馨&#39;, &#39;colors&#39;: [&#39;粉红色&#39;,&#39;白色&#39;,&#39;红色&#39;,&#39;紫色&#39;,&#39;黄色&#39;]&#125;&quot;</code></p>
<p>应该改为：</p>
<p><code>&#39;&#123;&quot;name&quot;: &quot;康乃馨&quot;, &quot;colors&quot;: [&quot;粉红色&quot;,&quot;白色&quot;,&quot;红色&quot;,&quot;紫色&quot;,&quot;黄色&quot;]&#125;&#39;</code></p>
<p>这样，你的JSON字符串就会使用正确的双引号格式，应该可以被正确地解析。</p>
<p>不过，这里我并不想这样解决问题，而是尝试使用OutputFixingParser来帮助咱们自动解决类似的格式错误。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 从langchain库导入所需的模块
from langchain.chat_models import ChatOpenAI
from langchain.output_parsers import OutputFixingParser

# 设置OpenAI API密钥
import os
os.environ["OPENAI_API_KEY"] = '你的OpenAI API Key'

# 使用OutputFixingParser创建一个新的解析器，该解析器能够纠正格式不正确的输出
new_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())

# 使用新的解析器解析不正确的输出
result = new_parser.parse(misformatted) # 错误被自动修正
print(result) # 打印解析后的输出结果
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>用上面的新的new_parser来代替Parser进行解析，你会发现，JSON格式的错误问题被解决了，程序不再出错。</p>
<p>输出如下：</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">name='Rose' colors=['red', 'pink', 'white']
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里的秘密在于，在OutputFixingParser内部，调用了原有的PydanticOutputParser，如果成功，就返回；如果失败，它会将格式错误的输出以及格式化的指令传递给大模型，并要求LLM进行相关的修复。</p>
<p>神奇吧，大模型不仅给我们提供知识，还随时帮助分析并解决程序出错的信息。</p>
<h2 id="重试解析器（RetryWithErrorOutputParser）实战"><a href="#重试解析器（RetryWithErrorOutputParser）实战" class="headerlink" title="重试解析器（RetryWithErrorOutputParser）实战"></a>重试解析器（RetryWithErrorOutputParser）实战</h2><p>OutputFixingParser不错，但它只能做简单的格式修复。如果出错的不只是格式，比如，输出根本不完整，有缺失内容，那么仅仅根据输出和格式本身，是无法修复它的。</p>
<p>此时，通过实现输出解析器中parse_with_prompt方法，LangChain提供的重试解析器可以帮助我们利用大模型的推理能力根据原始提示找回相关信息。</p>
<p>我们通过分析一个重试解析器的用例来理解上面的这段话。</p>
<p>首先还是设计一个解析过程中的错误。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 定义一个模板字符串，这个模板将用于生成提问
template = """Based on the user question, provide an Action and Action Input for what step should be taken.
&#123;format_instructions&#125;
Question: &#123;query&#125;
Response:"""

# 定义一个Pydantic数据格式，它描述了一个"行动"类及其属性
from pydantic import BaseModel, Field
class Action(BaseModel):
    action: str = Field(description="action to take")
    action_input: str = Field(description="input to the action")

# 使用Pydantic格式Action来初始化一个输出解析器
from langchain.output_parsers import PydanticOutputParser
parser = PydanticOutputParser(pydantic_object=Action)

# 定义一个提示模板，它将用于向模型提问
from langchain.prompts import PromptTemplate
prompt = PromptTemplate(
    template="Answer the user query.\n&#123;format_instructions&#125;\n&#123;query&#125;\n",
    input_variables=["query"],
    partial_variables=&#123;"format_instructions": parser.get_format_instructions()&#125;,
)
prompt_value = prompt.format_prompt(query="What are the colors of Orchid?")

# 定义一个错误格式的字符串
bad_response = '&#123;"action": "search"&#125;'
parser.parse(bad_response) # 如果直接解析，它会引发一个错误
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于bad_response只提供了action字段，而没有提供action_input字段，这与Action数据格式的预期不符，所以解析会失败。</p>
<p>我们首先尝试用OutputFixingParser来解决这个错误。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain">from langchain.output_parsers import OutputFixingParser
from langchain.chat_models import ChatOpenAI
fix_parser = OutputFixingParser.from_llm(parser=parser, llm=ChatOpenAI())
parse_result = fix_parser.parse(bad_response)
print('OutputFixingParser的parse结果:',parse_result)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>OutputFixingParser的parse结果： <code>action=&#39;search&#39; action_input=&#39;query&#39;</code></p>
<p>我们来看看这个尝试解决了什么问题，没解决什么问题。</p>
<p><strong>解决的问题有：</strong></p>
<ul>
<li>不完整的数据：原始的bad_response只提供了action字段而没有action_input字段。OutputFixingParser已经填补了这个缺失，为action_input字段提供了值 <code>&#39;query&#39;</code>。</li>
</ul>
<p><strong>没解决的问题有：</strong></p>
<ul>
<li>具体性：尽管OutputFixingParser为action_input字段提供了默认值 <code>&#39;query&#39;</code>，但这并不具有描述性。真正的查询是 “Orchid（兰花）的颜色是什么？”。所以，这个修复只是提供了一个通用的值，并没有真正地回答用户的问题。</li>
<li>可能的误导： <code>&#39;query&#39;</code> 可能被误解为一个指示，要求进一步查询某些内容，而不是作为实际的查询输入。</li>
</ul>
<p>当然，还有更鲁棒的选择，我们最后尝试一下RetryWithErrorOutputParser这个解析器。</p>
<pre class="line-numbers language-plain" data-language="plain"><code class="language-plain"># 初始化RetryWithErrorOutputParser，它会尝试再次提问来得到一个正确的输出
from langchain.output_parsers import RetryWithErrorOutputParser
from langchain.llms import OpenAI
retry_parser = RetryWithErrorOutputParser.from_llm(
    parser=parser, llm=OpenAI(temperature=0)
)
parse_result = retry_parser.parse_with_prompt(bad_response, prompt_value)
print('RetryWithErrorOutputParser的parse结果:',parse_result)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这个解析器没有让我们失望，成功地还原了格式，甚至也根据传入的原始提示，还原了action_input字段的内容。</p>
<p>RetryWithErrorOutputParser的parse结果： <code>action=&#39;search&#39; action_input=&#39;colors of Orchid&#39;</code></p>
<h2 id="总结时刻"><a href="#总结时刻" class="headerlink" title="总结时刻"></a>总结时刻</h2><p>结构化解析器和Pydantic解析器都旨在从大型语言模型中获取格式化的输出。结构化解析器更适合简单的文本响应，而Pydantic解析器则提供了对复杂数据结构和类型的支持。选择哪种解析器取决于应用的具体需求和输出的复杂性。</p>
<p>自动修复解析器主要适用于纠正小的格式错误，它更加“被动”，仅在原始输出出现问题时进行修复。重试解析器则可以处理更复杂的问题，包括格式错误和内容缺失。它通过重新与模型交互，使得输出更加完整和符合预期。</p>
<p>在选择哪种解析器时，需要考虑具体的应用场景。如果仅面临格式问题，自动修复解析器可能足够；但如果输出的完整性和准确性至关重要，那么重试解析器可能是更好的选择。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol>
<li>到目前为止，我们已经使用了哪些LangChain输出解析器？请你说一说它们的用法和异同。同时也请你尝试使用其他类型的输出解析器，并把代码与大家分享。</li>
<li>为什么大模型能够返回JSON格式的数据，输出解析器用了什么魔法让大模型做到了这一点？</li>
<li>自动修复解析器的“修复”功能具体来说是怎样实现的？请做debug，研究一下LangChain在调用大模型之前如何设计“提示”。</li>
<li>重试解析器的原理是什么？它主要实现了解析器类的哪个可选方法？</li>
</ol>
<p>题目较多，可以选择性思考，期待在留言区看到你的分享。如果你觉得内容对你有帮助，也欢迎分享给有需要的朋友！最后如果你学有余力，可以进一步学习下面的延伸阅读。</p>
<h2 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h2><ol>
<li>工具： <a target="_blank" rel="noopener" href="https://docs.pydantic.dev/latest/">Pydantic</a> 是一个Python库，用于数据验证，可以确保数据符合特定的格式</li>
<li>文档：LangChain中的各种 <a target="_blank" rel="noopener" href="https://python.langchain.com/docs/modules/model_io/output_parsers/">Output Parsers</a></li>
</ol>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#07%EF%BD%9C%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%EF%BC%9A%E7%94%A8OutputParser%E7%94%9F%E6%88%90%E9%B2%9C%E8%8A%B1%E6%8E%A8%E8%8D%90%E5%88%97%E8%A1%A8"><span class="toc-number">1.</span> <span class="toc-text">07｜输出解析：用OutputParser生成鲜花推荐列表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#LangChain-%E4%B8%AD%E7%9A%84%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text">LangChain 中的输出解析器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pydantic%EF%BC%88JSON%EF%BC%89%E8%A7%A3%E6%9E%90%E5%99%A8%E5%AE%9E%E6%88%98"><span class="toc-number">1.2.</span> <span class="toc-text">Pydantic（JSON）解析器实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9E%8B%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">第一步：创建模型实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%EF%BC%9A%E5%AE%9A%E4%B9%89%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">第二步：定义输出数据的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E8%BE%93%E5%87%BA%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">第三步：创建输出解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%EF%BC%9A%E5%88%9B%E5%BB%BA%E6%8F%90%E7%A4%BA%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.2.4.</span> <span class="toc-text">第四步：创建提示模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E6%AD%A5%EF%BC%9A%E7%94%9F%E6%88%90%E6%8F%90%E7%A4%BA%EF%BC%8C%E4%BC%A0%E5%85%A5%E6%A8%A1%E5%9E%8B%E5%B9%B6%E8%A7%A3%E6%9E%90%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.5.</span> <span class="toc-text">第五步：生成提示，传入模型并解析输出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E4%BF%AE%E5%A4%8D%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88OutputFixingParser%EF%BC%89%E5%AE%9E%E6%88%98"><span class="toc-number">1.3.</span> <span class="toc-text">自动修复解析器（OutputFixingParser）实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E8%A7%A3%E6%9E%90%E5%99%A8%EF%BC%88RetryWithErrorOutputParser%EF%BC%89%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.</span> <span class="toc-text">重试解析器（RetryWithErrorOutputParser）实战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%97%B6%E5%88%BB"><span class="toc-number">1.5.</span> <span class="toc-text">总结时刻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">思考题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="toc-number">1.7.</span> <span class="toc-text">延伸阅读</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 码农张三</div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>