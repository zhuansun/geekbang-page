<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>13 | 魔数0x5f3759df | geekbang</title><meta name="author" content="码农张三"><meta name="copyright" content="码农张三"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="13 | 魔数0x5f3759df你好，我是陈皓，网名左耳朵耗子。 下列代码是在《雷神之锤III竞技场》源代码中的一个函数（已经剥离了C语言预处理器的指令）。其实，最早在2002年（或2003年）时，这段平方根倒数速算法的代码就已经出现在Usenet与其他论坛上了，并且也在程序员圈子里引起了热烈的讨论。 我先把这段代码贴出来，具体如下： float Q_rsqrt( float number )">
<meta property="og:type" content="article">
<meta property="og:title" content="13 | 魔数0x5f3759df">
<meta property="og:url" content="https://zhuansun.github.io/geekbang/posts/2409177479.html">
<meta property="og:site_name" content="geekbang">
<meta property="og:description" content="13 | 魔数0x5f3759df你好，我是陈皓，网名左耳朵耗子。 下列代码是在《雷神之锤III竞技场》源代码中的一个函数（已经剥离了C语言预处理器的指令）。其实，最早在2002年（或2003年）时，这段平方根倒数速算法的代码就已经出现在Usenet与其他论坛上了，并且也在程序员圈子里引起了热烈的讨论。 我先把这段代码贴出来，具体如下： float Q_rsqrt( float number )">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg">
<meta property="article:published_time" content="2023-10-20T09:48:40.000Z">
<meta property="article:modified_time" content="2024-03-21T11:07:56.807Z">
<meta property="article:author" content="码农张三">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zhuansun.github.io/geekbang/posts/2409177479"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '13 | 魔数0x5f3759df',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-21 11:07:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="geekbang" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pic.imgdb.cn/item/653470a0c458853aef5813f1.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">1345</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">23</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">geekbang</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">13 | 魔数0x5f3759df</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-10-20T09:48:40.000Z" title="发表于 2023-10-20 09:48:40">2023-10-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A6%E8%80%B3%E5%90%AC%E9%A3%8E/">左耳听风</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="13-魔数0x5f3759df"><a href="#13-魔数0x5f3759df" class="headerlink" title="13 | 魔数0x5f3759df"></a>13 | 魔数0x5f3759df</h1><p>你好，我是陈皓，网名左耳朵耗子。</p>
<p>下列代码是在《雷神之锤III竞技场》源代码中的一个函数（已经剥离了C语言预处理器的指令）。其实，最早在2002年（或2003年）时，这段平方根倒数速算法的代码就已经出现在Usenet与其他论坛上了，并且也在程序员圈子里引起了热烈的讨论。</p>
<p>我先把这段代码贴出来，具体如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">float</span> <span class="token function">Q_rsqrt</span><span class="token punctuation">(</span> <span class="token keyword">float</span> number <span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">long</span> i<span class="token punctuation">;</span>
    <span class="token keyword">float</span> x2<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">float</span> threehalfs <span class="token operator">=</span> <span class="token number">1.5F</span><span class="token punctuation">;</span>

    x2 <span class="token operator">=</span> number <span class="token operator">*</span> <span class="token number">0.5F</span><span class="token punctuation">;</span>
    y  <span class="token operator">=</span> number<span class="token punctuation">;</span>
    i  <span class="token operator">=</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token keyword">long</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>y<span class="token punctuation">;</span> <span class="token comment">// evil floating point bit level hacking</span>
    i  <span class="token operator">=</span> <span class="token number">0x5f3759df</span> <span class="token operator">-</span> <span class="token punctuation">(</span> i <span class="token operator">>></span> <span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// what the fuck?</span>
    y  <span class="token operator">=</span> <span class="token operator">*</span> <span class="token punctuation">(</span> <span class="token keyword">float</span> <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token operator">&amp;</span>i<span class="token punctuation">;</span>
    y  <span class="token operator">=</span> y <span class="token operator">*</span> <span class="token punctuation">(</span> threehalfs <span class="token operator">-</span> <span class="token punctuation">(</span> x2 <span class="token operator">*</span> y <span class="token operator">*</span> y <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 1st iteration</span>
    <span class="token comment">// 2nd iteration, this can be removed</span>
    <span class="token comment">// y  = y * ( threehalfs - ( x2 * y * y ) );</span>

    <span class="token keyword">return</span> y<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码初读起来，我是完全不知所云，尤其是那个魔数0x5f3759df，根本不知道它是什么意思，所以，注释里也是 What the fuck。今天这节课，我主要就是想带你来了解一下这个函数中的代码究竟是怎样出来的。</p>
<p>其实，这个函数的作用是求平方根倒数，即$x^{-1&#x2F;2}$，也就是下面这个算式：</p>
<p>$$\frac{1}{\sqrt{x}}$$</p>
<p>当然，它算的是近似值。只不过这个近似值的精度很高，而且计算成本比传统的浮点数运算平方根的算法低太多。在以前那个计算资源还不充分的年代，在一些3D游戏场景的计算机图形学中，要求取照明和投影的光照与反射效果，就经常需要计算平方根倒数，而且是大量的计算——对一个曲面上很多的点做平方根倒数的计算。也就是需要用到下面的这个算式，其中的x,y,z是3D坐标上的一个点的三个坐标值。</p>
<p>$$\frac{1}{\sqrt{x^{2}+y^{2}+z^{2}}}$$</p>
<p>基本上来说，在一个3D游戏中，我们每秒钟都需要做上百万次平方根倒数运算。而在计算硬件还不成熟的时代，这些计算都需要软件来完成，计算速度非常慢。</p>
<p>我们要知道，在上世纪90年代，多数浮点数操作的速度更是远远滞后于整数操作。所以，这段代码所带来的作用是非常大的。</p>
<h1 id="计算机的浮点数表示"><a href="#计算机的浮点数表示" class="headerlink" title="计算机的浮点数表示"></a>计算机的浮点数表示</h1><p>为了讲清楚这段代码，我们需要先了解一下计算机的浮点数表示法。在C语言中，计算机的浮点数表示用的是IEEE 754 标准，这个标准的表现形式其实就是把一个32bits分成三段。</p>
<ul>
<li>第一段占1bit，表示符号位。代称为S（sign）。</li>
<li>第二段占8bits，表示指数。代称为E（Exponent）。</li>
<li>第三段占23bits，表示尾数。代称为M（Mantissa）。</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/cfb465ac3800ceb3f8a8997fe527c8a2.jpg"></p>
<p>然后呢，一个小数的计算方式是下面这个算式：</p>
<p>$$(-1)^{S}\ast(1+\frac{M}{2^{23}})\ast 2^{(E-127)}$$</p>
<p>但是，这个算式基本上来说，完全就是让人一头雾水，摸不着门路。对于浮点数的解释基本上就是下面这张漫画里表现的样子。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/7d607f3f90fe6e8152e2268da18e1feb.png"></p>
<p>下面，让我来试着解释一下浮点数的那三段表示什么意思。</p>
<ul>
<li><p>第一段符号位。对于这一段，我相信应该没有人不能理解。</p>
</li>
<li><p>第二段指数位。什么叫指数？也就是说，对于任何数x，其都可以找到一个$n$，使得$2^{n}$&lt;&#x3D;x&lt;&#x3D;$2^{n+1}$。比如：对于3来说，因为 2 &lt; 3 &lt; 4，所以 n&#x3D;1。而浮点数的这个指数为了要表示0.00x的小数，所以需要有负数，这8个bits本来可以表示0-255。为了表示负的，取值要放在 [-127,128] 这个区间中。这就是为什么我们在上面的公式中看到的 $2^{(E-127)}$这一项了。也就是说，$n &#x3D; E-127$，如果$n&#x3D;1$，那么$E$就是128了。</p>
</li>
<li><p>第三段尾数位。也就是小数位，但是这里叫偏移量可能好一些。这里的取值是在[ 0 - $2^{23}$]中。你可以认为，我们把一条线分成$2^{23}$个线段，也就是8388608个线段。也就是说，把$2^{n}$到$2^{n+1}$分成了8388608个线段。而存储的M值，就是从$2^n$到 x 要经过多少个段。这要计算一下，$2^{n}$到x的长度占$2^{n}$到$2^{n+1}$长度的比例是多少。</p>
</li>
</ul>
<p>我估计你对第三段还是有点不懂，那么我们来举一个例子。比如说，对3.14这个小数。</p>
<ul>
<li><p>是正数。所以，S &#x3D; 0。</p>
</li>
<li><p>$2^1$ &lt; 3.14 &lt;$2^2$。所以，n&#x3D;1， n+127 &#x3D; 128。所以，E&#x3D;128。</p>
</li>
<li><p>(3.14 - 2) &#x2F; (4 - 2) &#x3D; 0.57， 而$0.57*2^{23} &#x3D; 4781506.56$，四舍五入，得到M &#x3D; 4781507。因为有四舍五入，所以，产生了浮点数据的精度问题。</p>
</li>
</ul>
<p>把S、E、M转成二进制，得到 3.14的二进制表示。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/3f99e711a80ebe963bd5ca4139224915.jpg"></p>
<p>我们再用IEEE 754的那个算式来算一下：</p>
<p>$${(-1)}^0*({1+\frac{4781507}{2^{23}}})*2^{(128-127)}$$</p>
<p>$$&#x3D;1*(1+0.5700000524520874)*2$$</p>
<p>$$&#x3D;3.1400001049041748046875$$</p>
<p>你看，浮点数的精度问题出现了。</p>
<p>我们再来看一个示例，小数 0.015。</p>
<ul>
<li><p>是正数。所以，S &#x3D; 0。</p>
</li>
<li><p>$2^{-7}&lt; 0.015 &lt; 2^{-6}$ 。所以，n&#x3D;-7， n+127 &#x3D; 120。所以，E&#x3D;120。</p>
</li>
<li><p>$ (0.015 - 2^{-7}) &#x2F; (2^{-6} - 2^{-7}) $ &#x3D; $0.0071875&#x2F;0.0078125&#x3D;0.92$。而$0.92 * 2^{23} &#x3D; 7717519.36$，四舍五入，得到 M &#x3D; 7717519。</p>
</li>
</ul>
<p>于是，我们得到0.015的二进制编码：</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/bd3c8cae032d818084f2d1ac0a02acde.jpg"></p>
<p>其中：</p>
<ul>
<li>120 的二进制是01111000</li>
<li>7717519的二进制是11101011100001010001111</li>
</ul>
<p>返回过来算一下：</p>
<p>$$(-1)^{0}\ast (1+\frac{7717519}{2^{23}})\ast 2^{(120-127)}$$</p>
<p>$$&#x3D;(1+0.919999957084656)*0.0078125$$</p>
<p>$$&#x3D;0.014999999664724$$</p>
<p>你看，浮点数的精度问题又出现了。</p>
<p>我们来用C语言验证一下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">float</span> x <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> y <span class="token operator">=</span> <span class="token number">0.015</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在我的Mac上用lldb 工具 Debug 一下。</p>
<pre class="line-numbers language-none"><code class="language-none">(lldb) frame variable
(float) x &#x3D; 3.1400001
(float) y &#x3D; 0.0149999997

(lldb) frame variable -f b
(float) x &#x3D; 0b01000000010010001111010111000011
(float) y &#x3D; 0b00111100011101011100001010001111
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>从结果上，完全验证了我们的方法。</p>
<p>好了，不知道你看懂了没有？我相信你应该看懂了。</p>
<h1 id="简化浮点数公式"><a href="#简化浮点数公式" class="headerlink" title="简化浮点数公式"></a>简化浮点数公式</h1><p>因为那个浮点数表示的公式有点复杂，我们简化一下：</p>
<p>$$(-1)^{S}\ast (1+\frac{M}{2^{23}})\ast 2^{(E-127)}$$</p>
<p>我们令，$m &#x3D; (\frac{M}{2^{23}} )$，$e &#x3D; (E-127)$。因为符号位在$y&#x3D; x^{-\frac{1}{2}}$的两端都是0（正数），也就可以去掉，所以浮点数的算式简化为：</p>
<p>$$(1+m)\ast2^{e}$$</p>
<p>上面这个算式是从一个32bits二进制计算出一个浮点数。这个32bits的整型算式是：</p>
<p>$$M+E\ast2^{23}$$</p>
<p>比如，0.015的32bits的二进制是：00111100011101011100001010001111，也就是整型的：</p>
<p>$$7717519+120\ast 2^{23}$$</p>
<p>$$&#x3D; 1014350479$$</p>
<p>$$&#x3D; 0X3C75C28F$$</p>
<h1 id="平方根倒数公式推导"><a href="#平方根倒数公式推导" class="headerlink" title="平方根倒数公式推导"></a>平方根倒数公式推导</h1><p>下面，你会看到好多数学公式，但是请你不要怕，因为这些数学公式只需要高中数学就能看懂的。</p>
<p>我们来看一下，平方根数据公式：</p>
<p>$$y&#x3D;\frac{1}{\sqrt[2]{x}}&#x3D;x^{-\frac{1}{2}}$$</p>
<p>等式两边取以2为基数的对数，就有了：</p>
<p>$$\log_2(y) &#x3D;-\frac{1}{2}\log_2(x)$$</p>
<p>因为我们实际上在算浮点数，所以将公式中的 x 和 y 分别用浮点数的那个浮点数的简化算式$ (1+ m)*2^e$替换掉。代入$\log()$公式中，我们也就有了下面的公式：</p>
<p>$$\log_{2} (1+m_y)+e_y$$</p>
<p>$$&#x3D;-\frac{1}{2}(\log_2(1+m_x)+e_x)$$</p>
<p>因为有对数，这公式看着就很麻烦，似乎不能再简化了。但是，我们知道，所谓的$m_x$或是$m_y$，其实是个在0和1区间内的小数。在这种情况下，$\log_2 (1.x)$接近一条直线。</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/2d2b69795d3aa4d07545f0bbe645574e.png"></p>
<p>那么我们就可以使用一个直线方程来代替，也就是：</p>
<p>$$\log_{2}(1+m)\approx m+\sigma $$</p>
<p>于是，我们的公式就简化成了：</p>
<p>$$m_y+\sigma+e_y\approx-\frac{1}{2}(m_x+\sigma+e_x)$$</p>
<p>因为$m &#x3D; (\frac{M}{2^{23}})$，$e &#x3D; (E-127)$，代入公式，得到：</p>
<p>$$\frac{M_y}{2^{23}}+\sigma+E_y-127$$</p>
<p>$$\approx-\frac{1}{2}(\frac{M_x}{2^{23}}+\sigma+E_x-127)$$</p>
<p>移项整理一下，把 σ 和127 从左边，移到右边：</p>
<p>$$\frac{M_y}{2^{23}}+E_y\approx-\frac{1}{2}(\frac{M_x}{2^{23}}+E_x)-\frac{3}{2}(\sigma-127)$$</p>
<p>再把整个表达式乘以$2^{23}$，得到：</p>
<p>$${M_y}+E_y{2^{23}}$$</p>
<p>$$\approx-\frac{1}{2}(M_x+E_x{2^{23}})-\frac{3}{2}(\sigma-127){2^{23}}$$</p>
<p>可以看到一个常数：$-\frac{3}{2}(\sigma-127){2^{23}}$，把负号放进括号里，变成$\frac{3}{2}(127-\sigma){2^{23}}$，并可以用一个常量代数R来取代，于是得到公式：</p>
<p>$${M_y}+E_y{2^{23}}\approx R-\frac{1}{2}(M_x+E_x{2^{23}})$$</p>
<p>还记得我们前面那个“浮点数32bits二进制整型算式” $M+E* 2^{23}$吗？假设，浮点数x的32bits的整型公式是：$I_x&#x3D; M_x+ E_x 2^{23}$，那么上面的公式就可以写成：</p>
<p>$$I_y\approx R-\frac{1}{2}I_x$$</p>
<h1 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h1><p>让我们回到文章的主题，那个平方根函数的代码。</p>
<p>首先是：</p>
<pre class="line-numbers language-none"><code class="language-none">i  &#x3D; * ( long * ) &amp;y; &#x2F;&#x2F; evil floating point bit level hacking
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这行代码就是把一个浮点数的32bits的二进制转成整型。也就是，前面我们例子里说过的，3.14的32bits的二进制是：01000000010010001111010111000011，整型是：1078523331。即y &#x3D; 3.14，i &#x3D; 1078523331。</p>
<p>然后是：</p>
<pre class="line-numbers language-none"><code class="language-none">i  &#x3D; 0x5f3759df - ( i &gt;&gt; 1 );  &#x2F;&#x2F; what the fuck?
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这就是：</p>
<pre class="line-numbers language-none"><code class="language-none">i  &#x3D; 0x5f3759df - ( i &#x2F; 2 );
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>也就是我们上面推导出来的那个公式：</p>
<p>$$I_y\approx R-\frac{1}{2}I_x$$</p>
<p>代码里的 R &#x3D; 0x5f3759df。</p>
<p>我们又知道，R &#x3D; $\frac{3}{2}(127-\sigma){2^{23}}$，把代码中的那个魔数代入，就可以计算出来：σ&#x3D; 0.0450465 。这个数是个神奇的数字，这个数是怎么算出来的，现在还没人知道。不过，我们先往下看后面的代码：</p>
<pre class="line-numbers language-none"><code class="language-none">x2 &#x3D; number * 0.5F;
y  &#x3D; * ( float * ) &amp;i;
y  &#x3D; y * ( threehalfs - ( x2 * y * y ) );  &#x2F;&#x2F; 1st iteration
&#x2F;&#x2F; 2nd iteration, this can be removed
&#x2F;&#x2F; y  &#x3D; y * ( threehalfs - ( x2 * y * y ) );
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这段代码相当于下面这个公式：</p>
<p>$$I_{y’} &#x3D; I_y(1.5-0.5 x I_y^2)$$</p>
<p>这个其实是“牛顿求根法”，这是一个为了找到一个 f(x)&#x3D; 0 的根而用一种不断逼近的计算方式。请看下图：</p>
<p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/d9c070d857b29966ecb9eeab49057ce0.jpg"></p>
<p>首先，初始值为X0，然后找到X0所对应的Y0（把X0代入公式得到Y0 &#x3D; f(X0)），然后在（X0,Y0）这个点上做一个切线，得到与X轴交汇的X1。再用X1做一次上述的迭代，得到X2，就这样一直迭代下去，一直找到，y &#x3D; 0时，x的值。</p>
<p>牛顿法的通用公式是：</p>
<p>$$x_{n+1}&#x3D;x_n-\frac{f(x_n)}{f’(x_n)}$$</p>
<p>于是，对于$y&#x3D; \frac{1}{\sqrt{x}}$来说，对固定的x（常数），我们求y使得$\frac{1}{y^2}-x&#x3D;0$，$f(y)&#x3D; \frac{1}{y^2} -x$ , $f’(y)&#x3D;\frac{-2}{y^3}$ 。 注意：$f’(y)$是$f(y)$关于y的导数。</p>
<p>代入上述的牛顿法的通用公式后得到：</p>
<p>$$y_{n+1}&#x3D;y_n-\frac{\frac{1}{y_n^2}-x}{\frac{-2}{y_n^3}}$$</p>
<p>$$&#x3D;\frac{y_n(3-xy_n^2)}{2}&#x3D;y_n(1.5-0.5xy_n^2)$$</p>
<p>正好就是我们上面的代码。</p>
<p>整个代码是，之前生成的整数操作产生首次近似值后，将首次近似值作为参数送入函数最后两句进行精化处理。代码中的两次迭代正是为了进一步提高结果的精度。但由于《雷神之锤III》的图形计算中并不需要太高的精度，所以代码中只进行了一次迭代，二次迭代的代码则被注释了。</p>
<h1 id="相关历史"><a href="#相关历史" class="headerlink" title="相关历史"></a>相关历史</h1><p>根据Wikipedia上的描述，《雷神之锤III》的代码直到QuakeCon 2005才正式放出，但早在2002年（或2003年）时，平方根倒数速算法的代码就已经出现在Usenet和其他论坛上了。最初人们猜测是《雷神之锤》的创始人John Carmack写下了这段代码，但他在回复询问他的邮件时否定了这个观点，并猜测可能是先前曾帮id Software优化《雷神之锤》的资深汇编程序员Terje Mathisen写下了这段代码。</p>
<p>而Mathisen的邮件里表示，在1990年代初，他只曾做过类似的实现，确切来说这段代码亦非他所作。现在所知的最早实现是由Gary Tarolli在SGI Indigo中实现的，但他亦坦承他仅对常数R的取值做了一定的改进，实际上他也不是作者。</p>
<p>在向以发明MATLAB而闻名的Cleve Moler查证后，Rys Sommefeldt则认为原始的算法是Ardent Computer公司的Greg Walsh所发明的，但他也没有任何确定性的证据能证明这一点。</p>
<p>不仅该算法的原作者不明，人们也仍无法确定当初选择这个“魔术数字”的方法。Chris Lomont曾做了个研究：他推算出了一个函数以讨论此速算法的误差，并找出了使误差最小的最佳R值0x5f37642f（与代码中使用的0x5f3759df相当接近）。但以之代入算法计算并进行一次牛顿迭代后，所得近似值之精度仍略低于代入0x5f3759df的结果。</p>
<p>因此，Lomont将目标改为查找在进行1-2次牛顿迭代后能得到最大精度的R值，在暴力搜索后得出最优R值为0x5f375a86，以此值代入算法并进行牛顿迭代，所得的结果都比代入原始值（0x5f3759df）更精确。于是他说，“如果可能我想询问原作者，此速算法是以数学推导还是以反复试错的方式求出来的？”</p>
<p>Lomont亦指出，64位的IEEE754浮点数（即双精度类型）所对应的魔术数字是0x5fe6ec85e7de30da。但后来的研究表明，代入0x5fe6eb50c7aa19f9的结果精确度更高（McEniry得出的结果则是0x5fe6eb50c7b537aa，精度介于两者之间）。</p>
<p>后来Charles McEniry使用了一种类似Lomont但更复杂的方法来优化R值。他最开始使用穷举搜索，所得结果与Lomont相同。而后他尝试用带权二分法寻找最优值，所得结果恰是代码中所使用的魔术数字0x5f3759df。因此，McEniry认为，这一常数最初或许便是以“在可容忍误差范围内使用二分法”的方式求得。</p>
<p>这可能是编程世界里最经典的魔数的故事，希望你能够从这节课中收获一些数学的基础知识。数学真是需要努力学习好的一门功课，尤其在人工智能火热的今天。</p>
</article><div class="tag_share"><div class="post_share"></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#13-%E9%AD%94%E6%95%B00x5f3759df"><span class="toc-number">1.</span> <span class="toc-text">13 | 魔数0x5f3759df</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E8%A1%A8%E7%A4%BA"><span class="toc-number">2.</span> <span class="toc-text">计算机的浮点数表示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E6%B5%AE%E7%82%B9%E6%95%B0%E5%85%AC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">简化浮点数公式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B3%E6%96%B9%E6%A0%B9%E5%80%92%E6%95%B0%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC"><span class="toc-number">4.</span> <span class="toc-text">平方根倒数公式推导</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">5.</span> <span class="toc-text">代码分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%8E%86%E5%8F%B2"><span class="toc-number">6.</span> <span class="toc-text">相关历史</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2023/10/21/vq13okXnTbxDG2R.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 - 2024 By 码农张三</div></div><script src="https://cdn.bootcdn.net/ajax/libs/mermaid/9.4.0/mermaid.min.js"></script></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div></div></body></html>