<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>geekbang</title>
  
  
  <link href="https://zhuansun.github.io/geekbang/atom.xml" rel="self"/>
  
  <link href="https://zhuansun.github.io/geekbang/"/>
  <updated>2023-12-13T15:14:51.603Z</updated>
  <id>https://zhuansun.github.io/geekbang/</id>
  
  <author>
    <name>码农张三</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01 | 初心：为什么成为一名程序员？</title>
    <link href="https://zhuansun.github.io/geekbang/posts/1524061582.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/1524061582.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="01-初心：为什么成为一名程序员？"><a href="#01-初心：为什么成为一名程序员？" class="headerlink" title="01 | 初心：为什么成为一名程序员？"></a>01 | 初心：为什么成为一名程序员？</h1><p>在走上程序的道路前，你不妨先问问自己成为程序员的初心是什么。回首往昔，我似乎是阴差阳错地走上了这条路，正因初心未明，所以早期的路上就多了很多迟疑和曲折。</p><p>人生路漫漫，在专栏的第一个模块里，我会和你讲讲自己走上程序道路的故事，希望这些故事能够给迷茫或者奋进中的你以启发。在人生的不同阶段里，我都喜欢做“复盘”，一方面审视过去的自己，另外一方面思索未来的方向。现在看来，这些有节奏的复盘也给我自己留下了深深的印记，也让我在某些关键节点的决策更加坚决。</p><h2 id="首次接触"><a href="#首次接触" class="headerlink" title="首次接触"></a>首次接触</h2><p>说起我和程序的渊源，大概可以回溯到二十多年前。</p><p>那时，我还在读初中二年级，那是四川一所少数民族中学，硬件条件不是太好。那是1995年，国际友人赞助赠送了学校几台苹果 II 代电脑。作为学校成绩名列前茅的学生，在比较重视分数排名的背景下我还算有点 “小特权”。这点“小特权”就是可以接触这批电脑，所以在那时我为了搞懂怎么 “玩” 这些电脑去学了下 BASIC 语言，然后在上面编程并在单调的绿色屏幕上画出了一些几何图形。</p><p>当时还挺有成就感的，一度畅想将来要考清华的计算机专业。可能，那时觉得清华就是最好的学校，而计算机和编程是当时的最爱。然而，实际情况是上了高中以后学习压力大增，再也没时间去 “玩” 这些电脑了，光应对考试已然应接不暇，渐渐就忘了初中那时的想法。</p><p>现在回想起来第一次接触程序的时候，感觉它们还算是好 “玩” 的，有一种智力上的挑战，但当时也不太可能想到十年后我将会以此为生，走上程序之路。</p><p>彼时，初心未有。</p><h2 id="选择专业"><a href="#选择专业" class="headerlink" title="选择专业"></a>选择专业</h2><p>对我们80后这一代人，高考算是人生第一次重要的选择了吧。</p><p>我那时高考填志愿，都是在考试前进行。高中三年，我都再没接触过程序了，早已忘记当年的想法。高考前，当时觉得自己对物理最有兴趣就填报了南京大学的物理系，应该也考虑过清华什么的，但没什么信心。</p><p>关于兴趣有一个有趣的说法：“往往并不是有兴趣才能做好，而是做好了才有兴趣。”高中后可能觉得当时物理学得还不错，所以就有了兴趣，并在填报高考志愿时选择了物理专业。</p><p>后来高考的结果，一方面信心不是很足，另一方面单科数学发挥也失常。南大的物理系没能上成，落到了第二志愿东北大学，调剂成了机械工程专业。这是一个随机调剂的专业，着实让我无比苦闷，学了一年后，我非常清楚，我并不喜欢这个专业，也看不清未来的职业前景。</p><p>再回首时你总会发现，有些最重要的人生路径选择，就这么有点 “无厘头” 地完成了。在面临人生重要路径的选择时，当时只考虑了兴趣，如今看来也没那么靠谱。应该多听听众人的看法，参考前人的路径，最后再自己做出决定。人生路径还是需要自己来主动、有意识地掌舵的。</p><p>彼时，初心已有，但却是混乱的。</p><h2 id="转换专业"><a href="#转换专业" class="headerlink" title="转换专业"></a>转换专业</h2><p>机械专业煎熬了两年，迎来了第二次选择专业的机会。</p><p>在我读完大二的时候，国家开始兴办软件学院，新开软件工程专业。我当时在机械专业也会学一门编程课：C 语言。那时对 C 语言比较感兴趣，而对专业课机械制图则完全无感，所以当机会出现时就义无反顾去转了专业。</p><p>新专业面向所有非计算机的工程专业招生，但有一个门槛是：高学费。当时，机械专业一年学费四千多点，而软件工程本科一年一万六，学费读一年就抵得上别人读四年了，这对一个工薪家庭的压力不算小。</p><p>总之，我就是这么阴差阳错地又绕到了计算机专业这条路上。作为一门新开专业，软件工程相对计算机专业更偏应用，对接企业用人需求。可见，当时（2002 年）整个 IT 行业已经面临人才缺乏的问题，国家之所以新开软件工程专业，恐怕也是经济规律在发挥作用，平衡供需两端。</p><p>于我而言，转换专业算是时代给予的机遇，我在懵懂中做出了一次正确的选择。当时并不明了，但如今回顾却是如此清晰：面对新开的软件工程专业，其实表明了一个信息，这个行业发展很快，前景很好。</p><p>人生路很长，走了一段，也需要时不时重新审视当前的路径是否适合，是否无意错过了前途更好的岔路口。</p><p>我如今会感到庆幸没有错过这个路口，当时的确是没想过从机械专业换到软件工程会有更好的发展前景，但就是这样，我绕绕弯弯、曲曲折折地入了行，成为了一名程序员。</p><p>彼时，初心虽已不乱，但依然未明。</p><h2 id="转换行业"><a href="#转换行业" class="headerlink" title="转换行业"></a>转换行业</h2><p>人的一生面临很多重要选择，除了高考选专业，我想转行也是其中之一。</p><p>入行后，一路走来也碰到过很多从其他行业转行成为程序员的人。曾经在招聘面试时碰到过两个程序员，他们一个是毕业于中医药大学，在药房工作两年后转行并干了 3 年；另外一个主修环境工程专业，在该行业工作 9 年后才转行程序员，并在这行干了 5 年。</p><p>那时我就在想，为什么他们都要转行做一名程序员呢？也许，客观上来说，行业的景气度让程序员的薪酬水平水涨船高。需求的持续上涨，吸引着更多的人进入，这也是经济规律。但主观上来说，可能我们也没有想好为什么就要转行成为一名程序员。</p><p>我转换到软件工程专业，毕业后顺利进入程序这行。早期一开始就是为一些传统行业公司写企业应用程序，提供 IT 服务，完成一份合同。工作五年后，我才渐渐明白，同样写程序，但为不同的行业写的程序价值真是完全不同。因此，我选择了切换到电商互联网行业来写程序。</p><p>而这一次的选择我很确定的是，至少我模糊地看到了这条路的前景，并坚定地在众多选项中排除其他路径。转行，不同的跨度，代价或大或小。但不转变就没代价吗？不见得，因为有时不做选择的代价可能更大。</p><p>此时，初心才算渐渐明了。</p><h2 id="心明行远"><a href="#心明行远" class="headerlink" title="心明行远"></a>心明行远</h2><p>在成长的路上，我先后经历了换专业、换城市、换行业。</p><p>去年底（2017）我适时地驻足回顾了一下从进入大学到如今这些年的学习、工作和成长经历。其中有一些重要的时间事件节点，我把它们连接起来，就成了我们大多数人的成长线。下图，是我过去18年的成长线：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/139a061b33fd0d711136c2846ff90c37.png"></p><p>在这张图上，选专业、换专业、换城市、换行业，这几个重要的人生选择点，我都用红色字体标记了。把过往的18年浓缩到一张图上后，我就清晰地看出了趋势，在切换行业之前，初心未明，成长的路上起起伏伏，波动很大，也因为不成熟的选择带来过巨大的落差感。</p><p>在工作的前几年，图上也有一段快速的自然成长期。因为这时我们就像一张白纸，只要是在认真地做事儿，总是能成长。这段时期，心其实是乱的，但因为忙而充实，也获得了很多成长，但它的问题是：这样的自然成长期有多长取决于你所做事情的天花板，所以才有了后面的一次切换城市带来的落差。</p><p>切换了行业，一路走到现在，前路不尽，心已明，行将远。</p><p>为什么成为一名程序员，初心若何？有人有天赋，有人凭兴趣，有人看前景。也许，你上路之初还未曾明了，但在路上不时叩问内心，找到初心，会走得更坚定，更长远。</p><p>闭上眼睛，你可以试着问自己走上程序道路的初心是否已经明了呢？欢迎给我留言，我们一起分享和讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;01-初心：为什么成为一名程序员？&quot;&gt;&lt;a href=&quot;#01-初心：为什么成为一名程序员？&quot; class=&quot;headerlink&quot; title=&quot;01 | 初心：为什么成为一名程序员？&quot;&gt;&lt;/a&gt;01 | 初心：为什么成为一名程序员？&lt;/h1&gt;&lt;p&gt;在走上程序的</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>03 | 初程：带上一份技能地图</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3139078807.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3139078807.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="03-初程：带上一份技能地图"><a href="#03-初程：带上一份技能地图" class="headerlink" title="03 | 初程：带上一份技能地图"></a>03 | 初程：带上一份技能地图</h1><p>程序世界是一片广阔的大地，相比我十多年前进入这个世界时，这片大地的边界又扩大了很多倍。初入程序世界难免迷茫，要在这个世界立足、生存，并得到很好的发展，应首要具备怎样的技能呢？未来的程序之路，先给自己准备一份基本的技能地图，先有图，再上路。</p><p>在程序的技能地图中，需要先开启和点亮哪些部分呢？回顾我过去的经历并结合现实的需要，可以从如下两个不同程度的维度来说明：</p><ul><li>掌握</li><li>了解</li></ul><p>掌握，意味着是一开始就要求熟练掌握的硬技能，这是生存之本。而至于掌握的深度，是动态的，倒是可以在行进过程中不断去迭代加深。了解，相对掌握不是必需，但也需要达到知其然的程度，甚至知其所以然更好。</p><h2 id="一、掌握"><a href="#一、掌握" class="headerlink" title="一、掌握"></a>一、掌握</h2><p>上路之初，需要掌握的核心生存技能有哪些呢？</p><h3 id="1-开发平台"><a href="#1-开发平台" class="headerlink" title="1.开发平台"></a>1.开发平台</h3><p>开发平台，它包括一种编程语言、附带的平台生态及相关的技术。在如今这个专业化分工越来越细的时代，开发平台决定了你会成为什么类型和方向的程序员。比如：服务端、客户端或前端开发等。其中进一步细分客户端还可以有 Windows、Mac、iOS 和 Android 等不同的平台。</p><p><strong>编程语言</strong></p><p>语言的选择基本决定了开发平台的性质，但有些语言可能例外，如：C++、JS、C# 等，这些语言都可以跨多个平台。但即使你选的是这些语言，基本也会归属到某一类平台上。好比你选了 C++，如果你去做了客户端开发，就很少可能再去用 C++ 写服务端程序了。</p><p>关于语言的选择，前面我已经写过了选择的逻辑，便不再多说。但选择了语言，我们不仅仅是熟悉语言自身的特性，还需要掌握支撑语言的平台库。Java 若仅从语言特性上来说，有其优点，但其瑕疵和缺陷也一直被吐槽，要是没有 JDK 强大的平台库支撑，想必也不会有今天的繁荣。</p><p><strong>平台生态</strong></p><p>与语言平台关联的还有其技术生态以及各种技术框架的繁荣程度。这些平台技术生态的存在让使用这门语言编程完成特定的任务变得容易和简单得多。Java 的生命力除了 JDK 的强大支撑，实际还有其平台生态的繁荣，也起了决定性的作用。</p><p>在选择了开发平台后，除了语言和平台库之外，其生态体系内主流的技术框架和解决方案也是必选的掌握内容。</p><h3 id="2-常用算法"><a href="#2-常用算法" class="headerlink" title="2.常用算法"></a>2.常用算法</h3><p>在学校学习的算法，基本是解决各种计算机科学问题的通用方法。</p><p>还记得在学校时看过一本算法经典书《算法导论》。刚又把这本书的目录翻了出来过了一遍，发现已经忘记了百分之七、八十的内容。因为忘记的这部分内容，在过去的十多年工作中我基本都没机会用上。那么掌握算法的目的是为了什么呢？</p><p>有时候你可能会觉得学校教科书上学习的经典算法，在实际工作中根本就用不上。我还记得考研的时候，专业考试课就是算法与数据结构，在考卷上随手写个排序、树遍历手到擒来。但到研究生毕业去参加腾讯校招面试时，让在白纸上手写一个快排算法，我被卡住了，自然也就没通过。因为好久已经没有进行这样的练习了，而在研究生阶段一年期的公司实习工作场景也没有这样的需求。</p><p>那么为什么还要学习这些经典算法？</p><p>算法，表达的是一个计算的动态过程，它引入了一个度量标准：时空复杂度。当我回思时，发现这个度量标准思维在工作十余年中一直在发挥作用。如今，几乎所有的经典算法都能在开发平台库里找到实现，不会再需要自己从头写。但结合工作实际的业务场景，我们需要去设计更贴合需求的算法，而只要是算法它都受到时空复杂度的约束，而我们只是在其中进行平衡与折衷。</p><p>学校教科书的经典算法，是剥离了业务场景的高度抽象，当时学来有种不知道用在哪里的感觉；如今回头结合真实的业务场景需求再看，会有一种恍然大悟之感。</p><h3 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3.数据结构"></a>3.数据结构</h3><p>数据结构通常都和算法一起出现，但算法表达的是动态特性，而数据结构表达的是一种静态的结构特性。大部分开发平台库都提供了最基础和常用的数据结构实现，这些都是我们需要熟悉并掌握的，包括：</p><ul><li>数组 Array</li><li>链表 Linked List</li><li>队列 Queues</li><li>堆栈 Stacks</li><li>散列 Hashes</li><li>集合 Sets</li></ul><p>另外，还有两种数据结构不属于基础结构，但在现实中有非常广泛的直接映射场景。</p><ul><li>树 Trees</li><li>图 Graphs</li></ul><p>每种结构都有各种变体，适用于不同的场景，甚至很多时候你还需要会组合不同的结构去解决一些更复杂的问题。</p><h2 id="二、了解"><a href="#二、了解" class="headerlink" title="二、了解"></a>二、了解</h2><p>需要了解的内容比需要掌握的更广泛，但了解了这些方面会让你更高效地协作并解决问题。</p><h3 id="1-数据存储"><a href="#1-数据存储" class="headerlink" title="1.数据存储"></a>1.数据存储</h3><p>不管你写什么样的程序系统，估计都离不开数据存储。数据是一个业务系统的核心价值所在，所以怎么存储不同类型的生产数据，是你必须要了解的。如今广泛流行的数据存储系统有下面三类：</p><ul><li>SQL 关系型数据库（如：MySQL、Oracle）</li><li>NoSQL 非关系型数据库（如：HBase、MongoDB）</li><li>Cache 缓存（如：Redis、Memcached）</li></ul><p>每一种数据存储系统都有其特定的特性和应用场景。作为程序员，我们通常的需求就是最有效地用好各类数据存储，那么按了解的深度需要依次知道如下几点：</p><ul><li>如何用？在什么场景下，用什么数据存储的什么特性？</li><li>它们是如何工作的？</li><li>如何优化你的使用方式？</li><li>它们的量化指标，并能够进行量化分析？</li></ul><p>这 4 点虽不要求一开始就能掌握到一定程度，但你最好一开始就有这个层次思维，在日后的工作中不断去迭代它的深度。</p><h3 id="2-测试方法"><a href="#2-测试方法" class="headerlink" title="2.测试方法"></a>2.测试方法</h3><p>为什么我们做开发还需要了解测试？</p><p>测试思维是一种与开发完全不同的思维模式。有一种流行的开发方法论叫 “测试驱动开发（TDD）”，它的流行不是没有道理的。在写代码的时候，用测试的思维与方式（提供单元测试）去审视和检测代码，也就是说明确要开发某个功能后，先思考如何对这个功能进行测试，并完成测试代码的编写，然后编写相关的代码满足这些测试用例。</p><p>开发与测试这两种相反视角的切入维度，能真正长期地提高你写代码的效率和水平。</p><h3 id="3-工程规范"><a href="#3-工程规范" class="headerlink" title="3.工程规范"></a>3.工程规范</h3><p>每一种开发平台和语言，估计都有其相应约定俗成的一些工程规范要求。最基础的工程规范是代码规范，包括两个方面：</p><ul><li>代码结构</li><li>代码风格</li></ul><p>像 Java 这么多年下来，逐渐形成了一种基于 Maven 的代码组织结构规范，这种约定俗成的代码结构规范省却了很多没必要的沟通。有时候，同样的内容，有更规范的结构，其可阅读性、理解性就能得到提升。</p><p>而至于代码风格，相对没那么标准化。但为了写出更清晰、易读的代码，我们至少要坚持自己写的代码具有某种一致性的风格。另外，除了风格问题，也可以借助静态代码检查工具来规避一些新手爱犯的低级错误，而老手也可以通过这些工具来找到自己的认知与习惯盲点。</p><h3 id="4-开发流程"><a href="#4-开发流程" class="headerlink" title="4.开发流程"></a>4.开发流程</h3><p>在开发流程方法论上，敏捷基本已经横扫天下，所以我们至少要了解下敏捷开发方法论。</p><p>虽然敏捷方法论定义了一些参考实践，但它依然是一组非常松散的概念。每个实践敏捷的开发团队，估计都会根据自己的理解和摸索建立一整套逐渐约定成型的开发流程规范。而为了和团队其他成员更好地协作，估计每个新加入团队的成员都需要了解团队演进形成的开发流程规范。</p><p>先了解，再优化。</p><h3 id="5-源码管理"><a href="#5-源码管理" class="headerlink" title="5.源码管理"></a>5.源码管理</h3><p>既然我们生产代码，自然也需要了解如何管理好代码。</p><p>在我的从业经历中，源码管理工具经历了从 CVS 到 SVN 再到 Git 的变迁。Git 诞生的背景是为 Linux 这样超大规模的开源项目准备的，自然决定了其能应对各种复杂场景的源码管理需求。所以，你至少要了解 Git，并用好它。</p><p>当工具变得越来越强大时，工具背后的思想其实更重要，对其的理解决定了我们应用工具的模式。而对源码进行管理的最基本诉求有以下三点：</p><ul><li>并行：以支持多特性，多人的并行开发</li><li>协作：以协调多人对同一份代码的编写</li><li>版本：以支持不同历史的代码版本切换</li></ul><p>最后，我把以上内容总结为如下一张图：红色区域相对更小而聚焦，是需要掌握的部分，要求深度；蓝色区域的部分更广而泛，需要广度。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/2b4179c8ab8f4b60d2632060f1451df4.png"></p><p>程序员的基础技能图</p><p>以上就是我回顾走过的路径后，觉得需要具备的一份基础技能图。十多年后，这张图上的每一个分类都出现了新的技术迭代，有了新的框架、算法和产品等，但它们并不过时，依然可以为你的技能点亮之路提供方向指引。也许，你程序生涯的第一个一万小时你就会花在这张图上了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;03-初程：带上一份技能地图&quot;&gt;&lt;a href=&quot;#03-初程：带上一份技能地图&quot; class=&quot;headerlink&quot; title=&quot;03 | 初程：带上一份技能地图&quot;&gt;&lt;/a&gt;03 | 初程：带上一份技能地图&lt;/h1&gt;&lt;p&gt;程序世界是一片广阔的大地，相比我十多</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>04 | 初感：别了校园，入了江湖</title>
    <link href="https://zhuansun.github.io/geekbang/posts/280490597.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/280490597.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.608Z</updated>
    
    <content type="html"><![CDATA[<h1 id="04-初感：别了校园，入了江湖"><a href="#04-初感：别了校园，入了江湖" class="headerlink" title="04 | 初感：别了校园，入了江湖"></a>04 | 初感：别了校园，入了江湖</h1><p>每年七月，盛夏，一种火辣兼有闷润的热，但在这份热辣中也有一丝略显冰凉的愁绪。一批刚毕业的学生，将要告别校园，进入职场：一个新的江湖。</p><p>一到毕业季，就会经常看到一些转发给新入行程序员的“老司机”指南，老实说，这些指南不少都是金玉良言。当年我毕业新入行时可不像现在有这么多发蒙解惑的“老司机”指南，所以坑都没少踩，若说有什么坑没掉进去，那一定都是因为运气。</p><p>当毕业生们看到前路如此多坑时，其实也不必有太大的心理压力，毕竟成长之路不可能是轻松的。我也是这样一路走过来的。所以，这篇就不写关于坑的指南了，而是分享一些我的故事和感悟，给刚踏上征程的你或你们吧。</p><h2 id="重剑无锋"><a href="#重剑无锋" class="headerlink" title="重剑无锋"></a>重剑无锋</h2><p>作为一名新入职的程序员，首要之事就是配备一台电脑。</p><p>这个时代基本都是标配笔记本了，近年公司给配的电脑都很不错了，程序员全是高配大屏的 Macbook Pro 了。遥想我第一份工作，领到的是一个二手华硕笔记本，应该是上一个离职的前辈用了好几年的，这也是我的第一个笔记本电脑。</p><p>程序员就应该配笔记本电脑，为什么必须是笔记本电脑？不可以是台式机吗？笔记本电脑之于程序员，就像剑之于剑客。剑客的剑是不应该离开身边的，稍有风吹草动，听风辨器，拔剑出鞘（程序员一声不发就掏出笔记本开始写代码）。</p><p>当招程序员时，若来者不问公司配备什么笔记本，一般也就属于大多数的普通程序员啦，不太可能是那种 “不滞于物，草木竹石均可为剑” 的独孤求败级高手。</p><p>但也会有少数人问公司配什么笔记本电脑的，当对公司提供的笔记本感觉不满意时，就会要求是否可以自备笔记本电脑，而由公司给予补贴。</p><p>后一类同学，对环境、工具和效率是敏感的，我觉着就会比前面那类要强，当然我没有具体统计数据，也是纯凭感觉。</p><p>我毕业那年，腾讯来学校招聘，本科年薪六万，硕士八万，博士十万，都是税前。那时我心中最好的笔记本应该还是 IBM 的 ThinkPad T 系列，最差也得 10000+ 起的价格吧。但现在年薪十万在一线的北上广深算相当普遍了吧？而笔记本还是一万，所以能买到很不错的笔记本已经不是什么难事了。若现在的公司再在程序员的 “剑” 上琢磨省钱那绝对是得不偿失了。</p><p>我的第一个二手华硕笔记本相比现在的超薄轻快的笔记本，那绝对算是相反的厚重慢了。所以我把它称为 “重剑”，和独孤前辈不同的是，他老人家是先用轻剑，再用重剑，而我是先用重剑，然后越用越轻了。</p><p>但只是一年后我换了公司，这把 “重剑” 就还了回去。到了第二家公司，入职后才发现公司不配笔记本电脑，全是台式机。你看，当年我就是那种没问公司配什么电脑的普通程序员，考虑那时确实台式机占据主流，并且笔记本还属于一般程序员至少要两三个月工资才能买得起一台趁手的奢侈品范畴，我也就忍了。</p><p>新入职没多久，熟悉了公司环境和老同事交接过来的一个旧系统，公司派我出差去客户现场开发调试。我满心以为出差至少得配个笔记本吧，但组长过来说我们这边出差都带台式机的。然后我看看组长一脸正气不带开玩笑的表情，再看看桌上台式机硕大的机箱和 17 寸的 CRT 显示器，瞠目结舌。</p><p>“显示器也要带去？” 我问。</p><p>“噢，显示器可以让公司 IT 部给你寄过去，但主机箱要自带，因为快递很容易弄坏。” 组长说。</p><p>“好吧…”</p><p>对话结束，我立马奔去广州太平洋电脑城，花了之前一年工作攒下来的一万块中的七千，买了一台只有 ThinkPad T 系价位零头的 R 系笔记本，之后这把 “剑” 陪伴了我五年。</p><p>初入职场的同学，既然选择了某个公司，最大的因素除了薪酬外，想必每个人都还有这样或那样的在意点。当年我最不满意的就是笔记本这个问题，但从工作第二年开始我一直都是自备笔记本工作，持续多年，没花多少钱，但少了很多折腾和不便。</p><p>再后来，我挣得稍微多了些，就又自己换了大内存加固态硬盘（SSD）的 Mac。刚换上 Mac 就惊喜地发现，以前一个 Java 工程编译打包下要 50 多秒，在 Mac 下只需要 20 秒了。考虑写程序的这么多年，每天我要执行多少次编译打包命令，虽然每次节省的时间不多，但总体来看它大大提高了我的效率。</p><p>为什么我要单独谈谈笔记本这件小事？因为这是我们程序员每天使用最多的工具，如果你不在乎你的工具，可能你也就不会在乎你的时间和效率。</p><h2 id="野蛮生长"><a href="#野蛮生长" class="headerlink" title="野蛮生长"></a>野蛮生长</h2><p>现在的公司基本都会给新入职的同学配备一个老员工，俗称 “导师”。</p><p>导师制的主要目的是帮助新员工迅速熟悉公司环境和融入团队中。这个初衷自然是没问题的，只是因为导师制其实不算正式的规章制度，更多是一种文化上的强制介入，但很多时候又没有绑定任何利益机制，所以它的效果实际上和个体差异有很大关系。</p><p>我觉着新入行的同学，尽量不要去依赖此类导师制。我并不是否定这种机制，而是提醒你不要形成心理依赖，觉着面临问题时，总是有人可以询问和帮忙。职场的第一个台阶就是形成独立性：独立承担职责的能力。这和协作没有冲突，团队协作可以算是履行职责的一种途径和手段。</p><p>就以简单的问问题为例，如果只抱着获得答案搞定自己的事情为出发点，一次、两次也就罢了，长此以往是不可行的。因为通过你问出什么样的问题，就可以看出你对这个问题做出了怎样的探索与思考，以及让你困惑的矛盾点在哪里。有些人就喜欢不假思索地问些 Google 都能够轻易回答的问题，形成路径依赖，虽然最终搞定了问题，但换得的评价却不会高，特别要省之戒之。</p><p>当你能够问出 Google 都不容易回答的问题时，这可能才是你真正走上职业程序员的开端。</p><p>知乎上有个问题：“普通人到底跟职业运动员有多大差距？”里面有个回答，以篮球运动为例给出一个生动的评分体系。假如巅峰时的迈克尔·乔丹算满分 100，那么国内顶级的球员，巅峰时的易建联可能刚刚及格得分在 60～70 之间，而大部分业余选手基本就在 0.1～0.N 之间波动了。</p><p>幸运的是程序员这个职业不像运动员那么惨烈，借用上面的评分标准，假如把奠定计算机行业基础的那一批图灵奖得主级别的程序员定义在 90～100 分档，那么我们很多靠编码为生的程序员基本都在 1～10 分档间分布，而业余的只是写写 Demo 的程序员可能就是在 0.1～0.N 之间了。</p><p>所以，进入职场后，你需要先把得分从小数提高到整数，再持续努努力提升到两位数，搞不好就成了行业某个垂直细分领域小有名气的专家了。</p><p>都不需要及格的分数，程序员就能获得不错的成就感和回报。只需要是巅峰者的十分之一或二十分之一，基本就能超越身边绝大多数人了。望着遥远的巅峰不停地去靠近，翻越身前脚下的一座座小山包，然后不知不觉就超越了自己。</p><p>总之，应像野草一样野蛮而快速地生长起来。</p><h2 id="青春有价"><a href="#青春有价" class="headerlink" title="青春有价"></a>青春有价</h2><p>青春，到底是无价，还是有价？</p><p>电影《寒战》里面有个情节，劫匪劫持了一辆警方的冲锋车和五名警员，勒索赎金时让警方自己算一辆冲锋车及其装备外加五名警员的性命值多少钱。然后电影里一阵眼花缭乱的计算得出了最终价格，大约九千多万港币。</p><p>后来采访导演问是怎么个算法，导演如是说：</p><blockquote><p>五个警员，若不在事件中死去，由现在到退休期间的十多二十年任职的每月薪酬、房屋及子女医疗津贴、加上假设退休前的职位升迁，香港市民平均年龄以男方 79 岁，女方 85.9 岁的生存上限而计算的长俸，并加上冲锋车流动武器库内的价值、冲锋车本身的车价及保险等最后算出来的总值。</p></blockquote><p>按这么一算，其实一生值不了多少钱啊。</p><p>年轻时候嘴边爱唠叨一句话叫：青春无价。其实从我们挣到第一份工资开始，人生就是有价的了。而最黄金时段的青春就在毕业后的十年内，这是大部分人心理和心智走向成熟的阶段，但这十年的价值从市场价格衡量来看是十分有限的。</p><p>对于2018 年的毕业生， BAT 三家给出的年薪大约二十万左右，换算到月上每月接近两万了。而另外很大一部分进不了 BAT 三家的毕业生可能平均拿不到那么高，但估计在一线城市一万是差不多的。这样一算，未来十年你觉得能挣多少钱？</p><p>喜欢从静止的视角看问题的人一算大概一年十来万，十年也就一百多万，这个收入相对目前一线城市的房价，还能安居乐业吗？</p><p>另外思考一个问题：你能在十年后做到相比刚毕业时稳定收入增长十倍吗？也就是说现在月薪一万的人，十年后能月入十万吗？难，非常难。不信我们下面仔细算算。</p><p>我们回到用动态的视角看前面那个问题，你持续学习，努力工作，年年涨薪 20%（注意我说的是年年，这很不容易，也许你会说跳一次槽就可能翻倍，但你能年年跳槽翻倍么），十年后你年的收入将是十年前的 6.2 倍，离十倍还有距离，但换算为年薪也有七八十万了。所以要想靠加薪加到月入十万真的是一件极难的事情，而且即使做到了也离我们心中的无价青春，还差很远吧？</p><p>认清了这个现实，我们明白了这十年的青春是十分有价的。所以这时有人说了，要去创业，才有可能突破。前两年（2015）都在鼓励万众创业，但真实的现实是，你要给目前的万众创业者一个稳定的七八十万年薪，80%+ 的创业者表示就会放弃创业了，这数据是来自 TOMsInsight 深度观察文《互联网乱世之下，那些人才流动中的心酸和无奈》对 100 个创业者的抽样调查。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/cfdf0449e59441880c7ad00cf1bfbd23.png"></p><p>TOMsInsight 创业者放弃公司的薪水额度抽样调查</p><p>那么持续努力的学习还有意义吗？我只是说你很难做到每年加薪 20%，但是却可以做到每年比去年的自己多增长 20% 的知识、见识和能力。而关于知识、见识和能力的积累与相应价值的变现，理论与现实的对比可能如下图，纵坐标：年薪（单位万），横坐标：工作年限。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/d3670ff4ab9b16b316c63522bcf5ff87.png"></p><p>年薪与工作年限概念图</p><p>现实不太可能因为你的能力每增长 20% 就会立刻体现在你的收入上。现实有两种可能：一种存在一个拐点让你的积累获得相应的价格体现，另一种也可能不存在这个拐点，停留在某个水平位。其中拐点就是我们现实中常说的机遇吧。</p><p>无论怎样，要想获得拐点出现的机遇，可能你也只能持续努力地积累下去。</p><p>关于人生的选择，从来都是 All In，可没有股票那种分批建仓的办法，写到这里想起了曾经在网上记录下来的几句话，现分享给你：</p><blockquote><p>我不停的擦拭手中的利剑，不是因为我喜欢它，也不是因为它能带来安全，只是因为，每当下一次冲锋的号角响起时，我能够迅速拔出，纵横厮杀，直至战斗结束，不让自己倒下。</p><p>……</p><p>生活在这样的时代，与其被迫上场，心怀恐惧，不如主动征伐，加入时代的滚滚大潮当中，去见识一下时代的风采，写下自己的故事。</p></blockquote><p>这个江湖会有你的故事吗？</p><p>在这里我分享了一些我刚入江湖的故事，那你有怎样的精彩故事呢？欢迎你留言，和我一起分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;04-初感：别了校园，入了江湖&quot;&gt;&lt;a href=&quot;#04-初感：别了校园，入了江湖&quot; class=&quot;headerlink&quot; title=&quot;04 | 初感：别了校园，入了江湖&quot;&gt;&lt;/a&gt;04 | 初感：别了校园，入了江湖&lt;/h1&gt;&lt;p&gt;每年七月，盛夏，一种火辣兼有</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>05 | 架构与实现：它们的连接与分界？</title>
    <link href="https://zhuansun.github.io/geekbang/posts/211695669.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/211695669.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="05-架构与实现：它们的连接与分界？"><a href="#05-架构与实现：它们的连接与分界？" class="headerlink" title="05 | 架构与实现：它们的连接与分界？"></a>05 | 架构与实现：它们的连接与分界？</h1><p>把一种想法、一个需求变成代码，这叫 “实现”，而在此之前，技术上有一个过程称为设计，设计中有个特别的阶段叫 “架构”。</p><p>程序员成长的很长一段路上，一直是在 “实现”，当有一天，需要承担起 “架构” 的责任时，可能会有一点搞不清两者的差异与界线。</p><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>架构是什么？众说纷纭。</p><p>架构（Architecture）一词最早源自建筑学术语，后来才被计算机科学领域借用。以下是其在维基百科（Wikipedia）中的定义：</p><blockquote><p>架构是规划、设计和构建建筑及其物理结构的过程与产物。在计算机工程中，架构是描述功能、组织和计算机系统实现的一组规则与方法。</p><p>Architecture is both the process and the product of planning,   designing, and constructing buildings and other physical structures. In computer engineering, “computer architecture” is a set of rules and methods that describe the functionality, organization, and implementation of computer systems.</p></blockquote><p>在建筑学领域，有一组清晰的规则和方法来定义建筑架构。但可惜，到目前为止，在计算机软件工程领域并没有如此清晰的一组规则与方法来定义软件架构。</p><p>好在经过多年的实践，行业里逐渐形成了关于软件架构的共同认知： <strong>软件系统的结构与行为设计</strong>。而实现就是围绕这种已定义的宏观结构去开发程序的过程。</p><h2 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h2><p>架构做什么？很多人会感觉糊里糊涂的。</p><p>我刚获得“架构师”称号时，也并不很明确架构到底在做什么，交付的是什么。后来不断在工作中去反思、实践和迭代，我才慢慢搞清楚架构工作和实现工作的差异与分界线。</p><p>从定义上，你已知道架构是一种结构设计，但它同时可能存在于不同的维度和层次上：</p><ul><li>高维度：指系统、子系统或服务之间的切分与交互结构。</li><li>中维度：指系统、服务内部模块的切分与交互结构。</li><li>低维度：指模块组成的代码结构、数据结构、库表结构等。</li></ul><p>在不同规模的团队中，存在不同维度的架构师，但不论工作在哪个维度的架构师，他们工作的共同点包括下面4个方面：</p><ol><li>确定边界：划定问题域、系统域的边界。</li><li>切分协作：切分系统和服务，目的是建立分工与协作，并行以获得效率。</li><li>连接交互：在切分的各部分之间建立连接交互的原则和机制。</li><li>组装整合：把切分的各部分按预期定义的规则和方法组装整合为一体，完成系统目标。</li></ol><p>有时，你会认为架构师的职责是要交付 “一种架构”，而这“一种架构” 的载体通常又会以某种文档的形式体现。所以，很容易误解架构师的工作就是写文档。但实际上 <strong>架构师的交付成果是一整套决策流，文档仅仅是交付载体</strong>，而且仅仅是过程交付产物，最终的技术决策流实际体现在线上系统的运行结构中。</p><p>而对于实现，你应该已经很清楚是在做什么了。但我在这里不妨更清晰地分解一下。实现的最终交付物是程序代码，但这个过程中会发生什么？一般会有下面6个方面的考虑：选型评估；程序设计；执行效率；稳定健壮；维护运维；集成部署。</p><p>下表为其对应的详细内容：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/9cf03e6bdb195f8eca40386e297e0d5b.png"></p><p>我以交付一个功能需求为例，讲述下这个过程。</p><p>实现一个功能，可能全部自己徒手做，也可能选择一些合适的库或框架，再从中找到需要的API。</p><p>确定了合适的选型后，需要从逻辑、控制与数据这三个方面进一步考虑程序设计：</p><ul><li>逻辑，即功能的业务逻辑，反映了真实业务场景流程与分支，包含大量业务领域知识。</li><li>控制，即考虑业务逻辑的执行策略，哪些可以并行执行，哪些可以异步执行，哪些地方又必须同步等待结果并串行执行？</li><li>数据，包括数据结构、数据状态变化和存取方式。</li></ul><p>开始编码实现时，你进一步要考虑代码的执行效率，需要运行多长时间？要求的最大等待响应时间能否满足？并发吞吐能力如何？运行的稳定性和各种边界条件、异常处理是否考虑到了？上线后，出现 Bug，相关的监控、日志能否帮助快速定位？是否有动态线上配置和变更能力，可以快速修复一些问题？新上线版本时，你的程序是否考虑了兼容老版本的问题等？</p><p>最后你开发的代码是以什么形态交付？如果是提供一个程序库，则需要考虑相关的依赖复杂度和使用便利性，以及未来的升级管理。如果是提供服务，就需要考虑服务调用的管理、服务使用的统计监控，以及相关的 SLA 服务保障承诺。</p><p>以上，就是我针对整个实现过程自己总结的一个思维框架。如果你每次写代码时，都能有一个完善的思维框架，应该就能写出更好的代码。这个思维框架是在过去多年的编程经验中逐步形成的，在过去每次写代码时如果漏掉了其中某个部分，后来都以某种线上 Bug 或问题的形式，让我付出了代价，做出了偿还。</p><p>“实现”作为一个过程，就是不断地在交付代码流。而完成的每一行代码，都包含了上面这些方面的考虑，而这些方面的所有判断也是一整套决策流，然后固化在了一块块的代码中。</p><p>因为实现是围绕架构来进行的，所以架构的决策流在先，一定程度上决定了实现决策流的方向与复杂度，而架构决策的失误，后续会成倍地放大实现的成本。</p><h2 id="关注点"><a href="#关注点" class="headerlink" title="关注点"></a>关注点</h2><p>架构与实现过程中，有很多很多的点值得关注，若要选择一个核心点，会是什么？</p><p>架构的一个核心关注点，如果只能是一个点，我想有一个很适合的字可以表达： 熵。“熵”是一个物理学术语，在热力学中表达系统的混乱程度，最早是“信息论之父”克劳德·艾尔伍德·香农借用了这个词，并将其引入了信息科学领域，用以表达系统的混乱程度。</p><p>软件系统或架构，不像建筑物会因为时间的流逝而自然损耗腐坏，它只会因为变化而腐坏。一开始清晰整洁的架构与实现随着需求的变化而不断变得浑浊、混乱。这也就意味着系统的“熵”在不断增高。</p><p>这里我用一个图展示软件系统“熵”值的生命周期变化，如下：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/ceb233b2c4c4088d2179cf8b0d7ad37a.png"></p><p>系统只要是活跃的，“熵”值就会在生命周期中不断波动。需求的增加和改变，就是在不断增加“熵”值（系统的混乱程度）。但软件系统的“熵”有个临界值，当达到并超过临界值后，软件系统的生命也基本到头了。这时，你可能将迫不得已采取一种行动：重写或对系统做架构升级。</p><p>如果你不关注、也不管理系统的“熵”值，它最终的发展趋势就如图中的蓝线，一直升高，达到临界点，届时你就不得不付出巨大的代价来进行系统架构升级。</p><p>而实现中重构与优化的动作则是在不断进行减“熵”，作出平衡，让系统的“熵”值在安全的范围内波动。</p><p>那么，关于实现的核心关注点，也就呼之欲出了，我们也可以用一个字表达：简。</p><p>简，是简单、简洁、简明、简化，都是在做减法，但不是简陋。关于实现的全部智慧都浓缩在了这一个字里，它不仅减少代码量，也减少了开发时间，减少了测试时间，减少了潜在 Bug 的数量，甚至减少了未来的维护、理解与沟通成本。</p><p>架构关注复杂度的变化，自然就会带来简化，而实现则应当顺着把“简”做到极致。</p><h2 id="断裂带"><a href="#断裂带" class="headerlink" title="断裂带"></a>断裂带</h2><p>架构与实现之间，存在一条鸿沟，这是它们之间的断裂带。</p><p>断裂带出现在架构执行过程之中，落在文档上的架构决策实际上是静态的，但真正的架构执行过程却是动态的。架构师如何准确地传递架构决策？而开发实施的效果又如何能与架构决策保持一致？在这个过程中出现实施与决策的冲突，就又需要重新协调沟通讨论以取得新的一致。</p><p>当系统规模比较小时，有些架构师一个人就能把全部的设计决策在交付期限内开发完成，这就避免了很多沟通协调的问题。好些年前，我就曾这样做过一个小系统的架构升级改造，但后来的系统越来越大，慢慢就需要几十人的团队来分工协作。光是准确传递决策信息，并维持住大体的一致性，就是一件非常有挑战的工作了。</p><p>当系统规模足够大了，没有任何架构师能够把控住全部的细节。在实践中，我的做法是定期对系统的状态做快照，而非去把握每一次大大小小的变化，因为那样直接就会让我过载。在做快照的过程中我会发现很多的细节，也许和我当初想的完全不一样，会产生出一种“要是我来实现，绝对不会是这样”的感慨。</p><p>但在我发现和掌握的所有细节中，我需要做一个判断，哪些细节上的问题会是战略性的，而我有限的时间和注意力，必须放在这样的战略性细节上。而其他大量的实现细节也许和我想的不同，但只要没有越出顶层宏观结构定义的边界即可。系统是活的，控制演化的方向是可行的，而妄图掌控演化过程的每一步是不现实的。</p><p>关注与把控边界，这就比掌控整个领地的范围小了很多，再确认领地中的战略要地，那么掌控的能力也就有了支撑。架构与实现的鸿沟会始终存在，在这条鸿沟上选择合适的地方建设桥梁，建设桥梁的地方必是战略要地。</p><h2 id="等效性"><a href="#等效性" class="headerlink" title="等效性"></a>等效性</h2><p>架构升级中，经常被问到一个问题：“这个架构能实现么？”</p><p>其实，这根本不是一个值得疑惑的问题。相对于建筑架构，软件架构过程其实更像是城市的规划与演变过程。有一定历史的城市，慢慢都会演变出所谓的旧城和新城。而新城相对于旧城，就是一次架构升级的过程。</p><p>城市规划师会对城市的分区、功能划分进行重新定位与规划。一个旧城所拥有的所有功能，如：社区、学校、医院、商业中心，难道新城会没有，或者说 “实现” 不了吗？</p><p>任何架构的可实现性，是完全等效的，但实现本身却不是等效的，对不同的人或不同的团队可实现性的可能、成本、效率是绝对不等效的。</p><p>近些年，微服务架构火了，很多人都在从曾经的单体应用架构升级到微服务架构。以前能实现的功能，换成微服务架构肯定也可以实现，只是编写代码的方式不同，信息交互的方式也不同。</p><p>架构升级，仅仅是一次系统的重新布局与规划，成本和效率的重新计算与设计，“熵”的重新分布与管理。</p><p>最后我归纳下：架构是关注系统结构与行为的决策流，而实现是围绕架构的程序开发过程；架构核心关注系统的“熵”，而实现则顺应“简”；架构注重把控系统的边界与 “要塞”，而实现则去建立 “领地”；所有架构的可实现性都是等效的，但实现的成本、效率绝不会相同。</p><p>文中提到，架构和实现之间有一条断裂带，而让架构与实现分道扬镳的原因有：</p><ul><li>沟通问题：如信息传递障碍。</li><li>水平问题：如技术能力不足。</li><li>态度问题：如偷懒走捷径。</li><li>现实问题：如无法变更的截止日期（Deadline）。</li></ul><p>以上都是架构执行中需要面对的问题，你还能想到哪些？欢迎给我留言，和我一起探讨。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;05-架构与实现：它们的连接与分界？&quot;&gt;&lt;a href=&quot;#05-架构与实现：它们的连接与分界？&quot; class=&quot;headerlink&quot; title=&quot;05 | 架构与实现：它们的连接与分界？&quot;&gt;&lt;/a&gt;05 | 架构与实现：它们的连接与分界？&lt;/h1&gt;&lt;p&gt;把一</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>06 | 模式与框架：它们的关系与误区？</title>
    <link href="https://zhuansun.github.io/geekbang/posts/2562291080.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/2562291080.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="06-模式与框架：它们的关系与误区？"><a href="#06-模式与框架：它们的关系与误区？" class="headerlink" title="06 | 模式与框架：它们的关系与误区？"></a>06 | 模式与框架：它们的关系与误区？</h1><p>在学习程序设计的路上，你一定会碰到“设计模式”，它或者给你启发，或者让你疑惑，并且你还会发现在不同的阶段遇到它，感受是不同的。而“开发框架”呢？似乎已是现在写程序的必备品。那么框架和模式又有何不同？它们有什么关系？在程序设计中又各自扮演什么角色呢？</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式，最早源自 GoF 那本已成经典的《设计模式：可复用面向对象软件的基础》一书。该书自诞生以来，在程序设计领域已被捧为“圣经”。</p><p>软件设计模式也是参考了建筑学领域的经验，早在建筑大师克里斯托弗·亚历山大（Christopher Alexander）的著作《建筑的永恒之道》中，已给出了关于“模式”的定义：</p><blockquote><p>每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的成功的解决方案，无须再重复相同的工作。</p></blockquote><p>而《设计模式》一书借鉴了建筑领域的定义和形式，原书中是这么说的：</p><blockquote><p>本书中涉及的设计模式并不描述新的或未经证实的设计，我们只收录那些在不同系统中多次使用过的成功设计；尽管这些设计不包括新的思路，但我们用一种新的、便于理解的方式将其展现给读者。</p></blockquote><p>虽然该书采用了清晰且分门别类的方式讲述各种设计模式，但我相信很多新入门的程序员在看完该书后还是会像我当年一样有困扰，无法真正理解也不知道这东西到底有啥用。</p><p>早年我刚开始学习 Java 和面向对象编程，并编写 JSP 程序。当我把一个 JSP 文件写到一万行代码时，自己终于受不了了，然后上网大量搜索到底怎样写 JSP 才是对的。之后，我就碰到了《设计模式》一书，读完了，感觉若有所悟，但再去写程序时，反而更加困扰了。</p><p>因为学 “设计模式” 之前，写程序是无所顾忌，属于拿剑就刺，虽无章法却还算迅捷。但学了一大堆 “招式” 后反而变得有点瞻前顾后，每次出剑都在考虑招式用对没，挥剑反倒滞涩不少。有人说：“设计模式，对于初窥门径的程序员，带来的麻烦简直不逊于它所解决的问题。”回顾往昔，我表示深有同感。</p><p>后来回想，那个阶段我把《设计模式》用成了一本 “菜谱” 配方书。现实是，没做过什么菜只是看菜谱，也只能是照猫画虎，缺少好厨师的那种能力——火候。初窥门径的程序员其实缺乏的就是这样的“火候”能力，所以在看《设计模式》时必然遭遇困惑。而这种“火候”能力则源自大量的编程设计实践，在具体的实践中抽象出模式的思维。</p><p>“设计模式” 是在描述一些抽象的概念，甚至还给它们起了一些专有名字，这又增加了一道弯儿、一层抽象。初窥门径的程序员，具体的实践太少，面临抽象的模式描述时难免困惑。但实践中，经验积累到一定程度的程序员，哪怕之前就没看过《设计模式》，他们却可能已经基于经验直觉地用起了某种模式。</p><p>前面我说过我刚学习编程时看过一遍《设计模式》，看完后反而带来更多的干扰，不过后来倒也慢慢就忘了。好些年后，我又重读了一遍，竟然豁然开朗起来，因为其中一些模式我已经在过往的编程中使用过很多次，另一些模式虽未碰到，但理解起来已不见困惑。到了这个阶段，其实我已经熟练掌握了从具体到抽象之间切换的思维模式，设计模式的 “招数” 看来就亲切了很多。</p><p>在我看来，模式是前人解决某类问题方式的总结，是一种解决问题域的优化路径。但引入模式也是有代价的。设计模式描述了抽象的概念，也就在代码层面引入了抽象，它会导致代码量和复杂度的增加。而衡量应用设计模式付出的代价和带来的益处是否值得，这也是程序员 “火候” 能力另一层面的体现。</p><p>有人说，设计模式是招数；也有人说，设计模式是内功。我想用一种大家耳熟能详的武功来类比：降龙十八掌。以其中一掌“飞龙在天”为例，看其描述：</p><blockquote><p>气走督脉，行手阳明大肠经商阳…此式跃起凌空，居高下击，以一飞冲天之式上跃，双膝微曲，提气丹田，急发掌劲取敌首、肩、胸上三路。</p></blockquote><p>以上，前半句是关于内功的抽象描述，后半部分是具体招数的描述，而设计模式的描述表达就与此有异曲同工之妙。所以，设计模式是内功和招数并重、相辅相成的 “武功”。</p><p>当你解决了一个前人从没有解决的问题，并把解决套路抽象成模式，你就创造了一招新的 “武功”，后来的追随者也许会给它起个新名字叫：某某模式。</p><h2 id="开发框架"><a href="#开发框架" class="headerlink" title="开发框架"></a>开发框架</h2><p>不知从何时起，写程序就越来越离不开框架了。</p><p>记得我还在学校时，刚学习 Java 不久，那时 Java 的重点是 J2EE（现在叫 Java EE 了），而 J2EE 的核心是 EJB。当我终于用“JSP + EJB + WebLogic（EJB 容器）+ Oracle数据库”搭起一个 Web 系统时，感觉终于掌握了 Java 的核心。</p><p>后来不久，我去到一家公司实习，去了以后发现那里的前辈们都在谈论什么 DI（依赖注入）和 IoC（控制反转）等新概念。他们正在把老一套的 OA 系统从基于 EJB 的架构升级到一套全新的框架上，而那套框架包含了一堆我完全没听过的新名词。</p><p>然后有前辈给我推荐了一本书叫 _J2EE Development Without EJB_，看完后让我十分沮丧，因为我刚刚掌握的 Java 核心技术 EJB 还没机会出手就已过时了。</p><p>从那时起，我开始知道了框架（Framework）这个词，然后学习了一整套的基于开源框架的程序开发方式，知道了为什么 EJB 是重量级的，而框架是轻量级的。当时 EJB 已步入暮年，而框架的春天才刚开始来临，彼时最有名的框架正好也叫 Spring。如今框架已经枝繁叶茂，遍地开花。</p><p>现在的编程活动中，已是大量应用框架，而框架就像是给程序员定制的开发脚手架。一个框架是一个可复用的设计组件，它统一定义了高层设计和接口，使得从框架构建应用程序变得非常容易。因此，框架可以算是打开“快速开发”与“代码复用”这两扇门的钥匙。</p><p>在如今这个框架遍地开花的时代，正因为框架过于好用、易于复用，所以也可能被过度利用。</p><p>在 Java 中，框架很多时候就是由一个或一些 jar 包组成的。早在前几年（2012 年的样子）接触到一个 Web 应用系统，当时我尝试去拷贝一份工程目录时，意外发现居然有接近 500M 大小，再去看依赖的 jar 包多达 117 个，着实吓了一跳。在 500M 工程目录拷贝进度条缓慢移动中，我在想：“如今的程序开发是不是患上了框架过度依赖症？”</p><p>我想那时应该没有人能解释清楚为什么这个系统需要依赖 117 个 jar 包之多，也许只是为了完成一个功能，引入了一个开源框架，而这个框架又依赖了其他 20 个 jar 包。</p><p>有时候，框架确实帮我们解决了大部分的脏活累活，如果运气好，这些框架的质量很高或系统的调用量不大，那么它们可能也就从来没引发过什么问题，我们也就不需要了解它们是怎么去解决那些脏活、累活的。但若不巧，哪天某个框架在某些情况下出现了问题，在搞不懂框架原理的情况下，就总会有人惊慌失措。</p><p>如今，框架带来的束缚在于，同一个问题，会有很多不同框架可供选择。如何了解、评估、选择与取舍框架，成了新的束缚。</p><p>一些知名框架都是从解决一个特定领域问题的微小代码集合开始发展到提供解决方案、绑定概念、限定编程模式，并尝试不断通用化来扩大适用范围。</p><p>这样的框架自然不断变得庞大、复杂、高抽象度。</p><p>我一直不太喜欢通用型的框架，因为通用则意味着至少要适用于大于两种或以上的场景，场景越多我们的选择和取舍成本越高。另外，通用意味着抽象度更高，而现实是越高的抽象度，越不容易被理解。例如，人生活在三维世界，理解三维空间是直观的，完全没有抽象，理解四维空间稍微困难点，那五维或以上理解起来就很困难了。</p><p>框架，既是钥匙，也是枷锁，既解放了我们，也束缚着我们。</p><h2 id="两者关系"><a href="#两者关系" class="headerlink" title="两者关系"></a>两者关系</h2><p>分析了模式，解读了框架，那么框架和模式有什么关系呢？</p><p>框架和模式的共同点在于，它们都提供了一种问题的重用解决方案。其中，框架是代码复用，模式是设计复用。</p><p>软件开发是一种知识与智力的活动，知识的积累很关键。框架采用了一种结构化的方式来对特定的编程领域进行了规范化，在框架中直接就会包含很多模式的应用、模式的设计概念、领域的优化实践等，都被固化在了框架之中。框架是程序代码，而模式是关于这些程序代码的知识。</p><p>比如像 Spring 这样的综合性框架的使用与最佳实践，就隐含了大量设计模式的套路，即使是不懂设计模式的初学者，也可以按照这些固定的编程框架写出符合规范模式的程序。但写出代码完成功能是一回事，理解真正的程序设计又是另外一回事了。</p><p>小时候，看过一部漫画叫《圣斗士》。程序员就像是圣斗士，框架是“圣衣”，模式是“流星拳“，但最重要的还是自身的“小宇宙”啊。</p><p>我相信在编程学习与实践的路上，你对设计模式与开发框架也有过自己的思考。欢迎给我留言，说说你有过怎样的认识变化和体会，我们一起讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;06-模式与框架：它们的关系与误区？&quot;&gt;&lt;a href=&quot;#06-模式与框架：它们的关系与误区？&quot; class=&quot;headerlink&quot; title=&quot;06 | 模式与框架：它们的关系与误区？&quot;&gt;&lt;/a&gt;06 | 模式与框架：它们的关系与误区？&lt;/h1&gt;&lt;p&gt;在学</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>08 | 代码与分类：工业级编程的代码分类与特征</title>
    <link href="https://zhuansun.github.io/geekbang/posts/2260972722.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/2260972722.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="08-代码与分类：工业级编程的代码分类与特征"><a href="#08-代码与分类：工业级编程的代码分类与特征" class="headerlink" title="08 | 代码与分类：工业级编程的代码分类与特征"></a>08 | 代码与分类：工业级编程的代码分类与特征</h1><p>编程，就是写代码，那么在真实的行业项目中你编写的这些代码可以如何分类呢？回顾我曾经写过的各种系统代码，按代码的作用，大概都可以分为如下三类：</p><ul><li>功能</li><li>控制</li><li>运维</li></ul><p>如果你想提高编程水平，写出优雅的代码，那么就必须要清晰地认识清楚这三类代码。</p><h2 id="一、功能"><a href="#一、功能" class="headerlink" title="一、功能"></a>一、功能</h2><p>功能代码，是实现需求的业务逻辑代码，反映真实业务场景，包含大量领域知识。</p><p>一个程序软件系统，拥有完备的功能性代码仅是基本要求。因为业务逻辑的复杂度决定了功能性代码的复杂度，所以要把功能代码写好，最难的不是编码本身，而是搞清楚功能背后的需求并得到正确的理解。之后的编码活动，就仅是一个“翻译”工作了：把需求“翻译”为代码。</p><p>当然，“翻译” 也有自己独有的技术和积累，并不简单。而且 “翻译” 的第一步要求是 “忠于原文”，也即真正地理解并满足用户的原始需求。可这个第一步的要求实现起来就很困难。</p><p>为什么搞清楚用户需求很困难？因为从用户心里想要的，到他最后得到的之间有一条长长的链条，如下所示：</p><blockquote><p>用户心理诉求 -&gt; 用户表达需求 -&gt; 产品定义需求 -&gt; 开发实现 -&gt; 测试验证 -&gt; 上线发布 -&gt; 用户验收</p></blockquote><p>需求信息源自用户的内心，然后通过表达显性地在这个链条上传递，最终固化成了代码，以程序系统的形态反馈给了用户。</p><p>但信息在这个链条中的每个环节都可能会出现偏差与丢失，即使最终整个链条上的各个角色都貌似达成了一致，完成了系统开发、测试和发布，但最终也可能发现用户的心理诉求要么表达错了，要么被理解错了。</p><p>因为我近些年一直在做即时通讯产品（IM），所以在这儿我就以微信这样一个国民级的大家都熟悉的即时通讯产品为样本，举个例子。</p><p>微信里有个功能叫：消息删除。你该如何理解这个功能背后的用户心理诉求呢？用户进行删除操作的期待和反馈又是什么呢？从用户发消息的角度，我理解其删除消息可能的诉求有如下几种：</p><ol><li>消息发错了，不想对方收到。</li><li>消息发了后，不想留下发过的痕迹，但期望对方收到。</li><li>消息已发了，对于已经收到的用户就算了，未收到的最好就别收到了，控制其传播范围。</li></ol><p>对于第一点，微信提供了两分钟内撤回的功能；而第二点，微信提供的删除功能正好满足；第三点，微信并没有满足。我觉着第三点其实是一个伪需求，它其实是第一点不能被满足情况下用户的一种妥协。</p><p>用户经常会把他们的需要，表达成对你的行为的要求，也就是说不真正告诉你要什么，而是告诉你要做什么。所以你才需要对被要求开发的功能进行更深入的思考。有时，即使是日常高频使用的产品背后的需求，你也未必能很好地理解清楚，而更多的业务系统其实离你的生活更远，努力去理解业务及其背后用户的真实需求，才是写好功能代码的基本能力。</p><p>程序存在的意义就在于实现功能，满足需求。而一直以来我们习惯于把完成客户需求作为程序开发的主要任务，当功能实现了便感觉已经完成了开发，但这仅仅是第一步。</p><h2 id="二、控制"><a href="#二、控制" class="headerlink" title="二、控制"></a>二、控制</h2><p>控制代码，是控制业务功能逻辑代码执行的代码，即业务逻辑的执行策略。</p><p>编程领域熟悉的各类设计模式，都是在讲关于控制代码的逻辑。而如今，很多这些常用的设计模式基本都被各类开源框架固化了进去。比如，在 Java 中，Spring 框架提供的控制反转（IoC）、依赖注入（DI）就固化了工厂模式。</p><p>通用控制型代码由各种开源框架来提供，程序员就被解放出来专注写好功能业务逻辑。而现今分布式领域流行的微服务架构，各种架构模式和最佳实践也开始出现在各类开源组件中。比如微服务架构模式下关注的控制领域，包括：通信、负载、限流、隔离、熔断、异步、并行、重试、降级。</p><p>以上每个领域都有相应的开源组件代码解决方案，而进一步将控制和功能分离的 “服务网格（Service Mesh）” 架构模式则做到了极致，控制和功能代码甚至运行在了不同的进程中。</p><p>控制代码，都是与业务功能逻辑不直接相关的，但它们和程序运行的性能、稳定性、可用性直接相关。提供一项服务，功能代码满足了服务的功能需求，而控制代码则保障了服务的稳定可靠。</p><p>有了控制和功能代码，程序系统终于能正常且稳定可靠地运行了，但难保不出现异常，这时最后一类 “运维” 型代码便要登场了。</p><h2 id="三、运维"><a href="#三、运维" class="headerlink" title="三、运维"></a>三、运维</h2><p>运维代码，就是方便程序检测、诊断和运行时处理的代码。它们的存在，才让系统具备了真正工业级的可运维性。</p><p>最常见的检测诊断性代码，应该就是日志了，打日志太过简单，因此我们通常也就疏于考虑。其实即使是打日志也需要有意识的设计，评估到底应该输出多少日志，在什么位置输出日志，以及输出什么级别的日志。</p><p>检测诊断代码有一个终极目标，就是让程序系统完成运行时的自检诊断。这是完美的理想状态，却很难在现实中完全做到。</p><p>因为它不仅仅受限于技术实现水平，也与实现的成本和效益比有关。所以，我们可以退而求其次，至少在系统异常时可以具备主动运行状态汇报能力，由开发和运维人员来完成诊断分析，这也是我们常见的各类系统或终端软件提供的机制。</p><p>在现实中，检测诊断类代码经常不是一开始就主动设计的。但生产环境上的程序系统可能会偶然出现异常或故障，而因为一开始缺乏检测诊断代码输出，所以很难找到真实的故障原因。现实就这样一步一步逼着你去找到真实原因，于是检测诊断代码就这么被一次又一次地追问为什么而逐渐完善起来了。</p><p>但如果一开始你就进行有意识地检测诊断设计，后面就会得到更优雅的实现。有一种编程模式：面向切面编程（AOP），通过早期的有意设计，可以把相当范围的检测诊断代码放入切面之中，和功能、控制代码分离，保持优雅的边界与距离。</p><p>而对于特定的编程语言平台，比如 Java 平台，有字节码增强相关的技术，可以完全干净地把这类检测诊断代码和功能、控制代码彻底分离。</p><p>运维类代码的另一种类，是方便在运行时，对系统行为进行改变的代码。通常这一类代码提供方便运维操作的 API 服务，甚至还会有专门针对运维提供的服务和应用，例如：备份与恢复数据、实时流量调度等。</p><p>功能、控制、运维，三类代码，在现实的开发场景中优先级这样依次排序。有时你可能仅仅完成了第一类功能代码就迫于各种压力上线发布了，但你要在内心谨记，少了后两类代码，将来都会是负债，甚至是灾难。而一个满足工业级强度的程序系统，这三类代码，一个也不能少。</p><p>而对三类代码的设计和实现，越是优雅的程序，这三类代码在程序实现中就越是能看出明显的边界。为什么需要边界？因为，“码以类聚，人以群分”。功能代码易变化，控制代码固复杂，运维代码偏繁琐，这三类不同的代码，不仅特征不同，而且编写它们的人（程序员）也可能分属不同群组，有足够的边界与距离才能避免耦合与混乱。</p><p>而在程序这个理性世界中，优雅有时就是边界与距离。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;08-代码与分类：工业级编程的代码分类与特征&quot;&gt;&lt;a href=&quot;#08-代码与分类：工业级编程的代码分类与特征&quot; class=&quot;headerlink&quot; title=&quot;08 | 代码与分类：工业级编程的代码分类与特征&quot;&gt;&lt;/a&gt;08 | 代码与分类：工业级编程的代</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>09 | 粗放与精益：编程的两种思路与方式</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3902393923.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3902393923.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="09-粗放与精益：编程的两种思路与方式"><a href="#09-粗放与精益：编程的两种思路与方式" class="headerlink" title="09 | 粗放与精益：编程的两种思路与方式"></a>09 | 粗放与精益：编程的两种思路与方式</h1><p>几年前，我给团队负责的整个系统写过一些公共库，有一次同事发现这个库里存在一个Bug，并告诉了我出错的现象。然后我便去修复这个Bug，最终只修改了一行代码，但发现一上午就这么过去了。</p><p>一上午只修复了一个Bug，而且只改了一行代码，到底发生了什么？时间都去哪里了？以前觉得自己写代码很快，怎么后来越来越慢了？我认真地思考了这个问题，开始认识到我的编程方式和习惯在那几年已经慢慢发生了变化，形成了明显的两个阶段的转变。这两个阶段是：</p><ul><li>写得粗放，写得多</li><li>写得精益，写得好</li></ul><h2 id="多与粗放"><a href="#多与粗放" class="headerlink" title="多与粗放"></a>多与粗放</h2><p>粗放，在软件开发这个年轻的行业里其实没有确切的定义，但在传统行业中确实存在相近的关于 “粗放经营” 的概念可类比。引用其百科词条定义如下：</p><blockquote><p>粗放经营（Extensive Management），泛指技术和管理水平不高，生产要素利用效率低，产品粗制滥造，物质和劳动消耗高的生产经营方式。</p></blockquote><p>若把上面这段话里面的 “经营” 二字改成 “编程”，就很明确地道出了我想表达的粗放式编程的含义。</p><p>一个典型的粗放式编程场景大概是这样的：需求到开发手上后，开始编码，编码完成，人肉测试，没问题后快速发布到线上，然后进入下一个迭代。</p><p>我早期参与的大量项目过程都与此类似，不停地重复接需求，快速开发，发布上线。在这个过程中，我只是在不停地堆砌功能代码，每天产出的代码量不算少，但感觉都很类似，也很粗糙。这样的过程持续了挺长一个阶段，一度让我怀疑：这样大量而粗放地写代码到底有什么作用和意义？</p><p>后来读到一个故事，我逐渐明白这个阶段是必要的，它因人、因环境而异，或长或短。而那个给我启发的故事，是这样的。</p><p>有一个陶艺老师在第一堂课上说，他会把班上学生分成两组，一组的成绩将会以最终完成的陶器作品数量来评定；而另一组，则会以最终完成的陶器品质来评定。</p><p>在交作业的时候，一个很有趣的现象出现了：“数量” 组如预期一般拿出了很多作品，但出乎意料的是质量最好的作品也全部是由 “数量” 组制作出来的。</p><p>按 “数量” 组的评定标准，他们似乎应该忙于粗制滥造大量的陶器呀。但实际情况是他们每做出一个垃圾作品，都会吸取上一次制作的错误教训，然后在做下一个作品时得到改进。</p><p>而 “品质” 组一开始就追求完美的作品，他们花费了大量的时间从理论上不断论证如何才能做出一个完美的作品，而到了最后拿出来的东西，似乎只是一堆建立在宏大理论上的陶土。</p><p>读完这个故事，我陷入了沉思，感觉故事里的制作陶器和编程提升之路是如此类似。很显然，“品质” 组的同学一开始就在追求理想上的 “好与精益” ，而 “数量” 组同学的完成方式则似我早期堆砌代码时的“多与粗放”，但他们正是通过做得多，不断尝试，快速迭代 ，最后取得到了更好的结果。</p><p>庆幸的是，我在初学编程时，就是在不断通过编程训练来解答一个又一个书本上得来的困惑；后来工作时，则是在不断写程序来解决一个又一个工作中遇到的问题。看到书上探讨各种优雅的代码之道、编程的艺术哲学，那时的我也完全不知道该如何通往这座编程的 “圣杯”，只能看着自己写出的蹩脚代码，然后继续不断重复去制作下一个丑陋的 “陶器”，不断尝试，不断精进和进阶。</p><p>《黑客与画家》书里说：“编程和画画近乎异曲同工。”所以，你看那些成名画家的作品，如果按时间顺序来排列展示，你会发现每幅画所用的技巧，都是建立在上一幅作品学到的东西之上；如果某幅作品特别出众，你往往也能在更早期的作品中找到类似的版本。而编程的精进过程也是类似的。</p><p>总之，这些故事和经历都印证了一个道理： <strong>在通往 “更好” 的路上，总会经过 “更多” 这条路。</strong></p><h2 id="好与精益"><a href="#好与精益" class="headerlink" title="好与精益"></a>好与精益</h2><p>精益，也是借鉴自传统行业里的一个类比：精益生产。</p><blockquote><p>精益生产（Lean Production），简言之，就是一种以满足用户需求为目标、力求降低成本、提高产品的质量、不断创新的资源节约型生产方式。</p></blockquote><p>若将定义中的 “生产” 二字换成 “编程”，也就道出了精益编程的内涵。它有几个关键点：质量、成本与效率。但要注意：在编程路上，如果一开始就像 “品质” 组同学那样去追求完美，也许你就会被定义 “完美” 的品质所绊住，而忽视了制作的成本与效率。</p><p>因为编程的难点是，无论你在开始动手编程时看过多少有关编程理论、方法、哲学与艺术的书，一开始你还是无法领悟到什么是编程的正确方法，以及什么是“完美” 的程序。毕竟纸上得来终觉浅，绝知此事要躬行。</p><p>曾经，还在学校学习编程时，有一次老师布置了一个期中课程设计，我很快完成了这个课程设计中的编程作业。而另一位同学，刚刚看完了那本经典的《设计模式》书。</p><p>他尝试用书里学到的新概念来设计这个编程作业，并且又用 UML 画了一大堆交互和类图，去推导设计的完美与优雅。然后兴致勃勃向我（因为我刚好坐在他旁边）讲解他的完美设计，我若有所悟，觉得里面确实有值得我借鉴的地方，就准备吸收一些我能听明白的东西，重构一遍已经写好的作业程序。</p><p>后来，这位同学在动手实现他的完美设计时，发现程序越写越复杂，交作业的时间已经不够了，只好借用我的不完美的第一版代码改改凑合交了。而我在这第一版代码基础上，又按领悟到的正确思路重构了一次、改进了一番后交了作业。</p><p>所以，别被所谓 “完美“ 的程序所困扰，只管先去盯住你要用编程解决的问题，把问题解决，把任务完成。</p><p><strong>编程，其实一开始哪有什么完美，只有不断变得更好。</strong></p><p>工作后，我做了大量的项目，发现这些项目都有很多类似之处。每次，即使项目上线后，我也必然重构项目代码，提取其中可复用的代码，然后在下一个项目中使用。循环往复，一直干了七八年。每次提炼重构，都是一次从 “更多” 走向 “更好” 的过程。我想，很多程序员都有类似的经历吧？</p><p>回到开头修改Bug 的例子，我用半天的时间改一个Bug，感觉效率不算高，这符合精益编程的思路吗？先来回顾下这半天改这个Bug 的过程。</p><p>由于出问题的那个公共库是我接到Bug 时的半年前开发的，所以发现那个Bug 后，我花了一些时间来回忆整个公共库的代码结构设计。然后我研究了一下，发现其出现的场景比较罕见，要不不至于线上运行了很久也没人发现，属于重要但不紧急。</p><p>因此，我没有立刻着手去修改代码，而是先在公共库的单元测试集中新写了一组单元测试案例。单元测试构建了该Bug的重现场景，并顺利让单元测试运行失败了，之后我再开始去修改代码，并找到了出问题的那一行，修改后重新运行了单元测试集，并顺利看见了测试通过的绿色进度条。</p><p>而作为一个公共库，修改完成后我还要为本次修改更新发布版本，编写对应的文档，并上传到 Maven 仓库中，才算完成。回想这一系列的步骤，我发现时间主要花在了构建重现Bug 的测试案例场景中，有时为了构建一个测试场景编写代码的难度可能比开发功能本身更困难。</p><p>为修改一个Bug 付出的额外单元测试时间成本，算一种浪费吗？虽说这确实提高了代码的修复成本，但也带来了程序质量的提升。按前面精益的定义，这似乎是矛盾的，但其实更是一种权衡与取舍。</p><p>就是在这样的过程与反复中，我渐渐形成了属于自己的编程价值观：世上没有完美的解决方案，任何方案总是有这样或那样一些因子可以优化。一些方案可能面临的权衡取舍会少些，而另一些方案则会更纠结一些，但最终都要做取舍。</p><p>以上，也说明了一个道理： <strong>好不是完美，好是一个过程，一个不断精益化的过程。</strong></p><p>编程，当写得足够多了，也足够好了，你才可能自如地在 “多” 与 “好” 之间做出平衡。</p><p>编程的背后是交付程序系统，交付关心的是三点：功能多少，质量好坏，效率快慢。真实的编程环境下， 你需要在三者间取得平衡，哪些部分可能是多而粗放的交付，哪些部分是好而精益的完成，同时还要考虑效率快慢（时间）的需求。</p><p>编程路上，“粗放的多” 是 “精益的好和快” 的前提，而好和快则是你的取舍：是追求好的极致，还是快的极致，或者二者的平衡？</p><p>在多而粗放和好而精益之间，现在你处在哪个阶段了？欢迎留言谈谈你的看法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;09-粗放与精益：编程的两种思路与方式&quot;&gt;&lt;a href=&quot;#09-粗放与精益：编程的两种思路与方式&quot; class=&quot;headerlink&quot; title=&quot;09 | 粗放与精益：编程的两种思路与方式&quot;&gt;&lt;/a&gt;09 | 粗放与精益：编程的两种思路与方式&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>12 | Bug的空间属性：环境依赖与过敏反应</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3534238967.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3534238967.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.620Z</updated>
    
    <content type="html"><![CDATA[<h1 id="12-Bug的空间属性：环境依赖与过敏反应"><a href="#12-Bug的空间属性：环境依赖与过敏反应" class="headerlink" title="12 | Bug的空间属性：环境依赖与过敏反应"></a>12 | Bug的空间属性：环境依赖与过敏反应</h1><p>从今天开始，咱们专栏进入 “程序之术” 中关于写代码的一个你可能非常熟悉，却也常苦恼的小主题：Bug。</p><p>写程序的路上，会有一个长期伴随你的 “同伴”：Bug，它就像程序里的寄生虫。不过，Bug 最早真的是一只虫子。</p><p>1947年，哈佛大学的计算机哈佛二代（Harvard Mark II）突然停止了运行，程序员在电路板编号为 70 的中继器触点旁发现了一只飞蛾。然后把飞蛾贴在了计算机维护日志上，并写下了首个发现 Bug 的实际案例。程序错误从此被称作 Bug。</p><p>这只飞蛾也就成了人类历史上的第一个程序 Bug。</p><p>回想下，在编程路上你遇到得最多的 Bug 是哪类？我的个人感受是，经常被测试或产品经理要求修改和返工的 Bug。这类 Bug 都来自于对需求理解的误差，其实属于沟通理解问题，我并不将其归类为真正的技术性 Bug。</p><p>技术性 Bug 可以从很多维度分类，而我则习惯于从 Bug 出现的 “时空” 特征角度来分类。可划为如下两类：</p><ul><li>空间：环境过敏</li><li>时间：周期规律</li></ul><p>我们就先看看 Bug 的 <strong>空间维度</strong> 特征。</p><h2 id="环境过敏"><a href="#环境过敏" class="headerlink" title="环境过敏"></a>环境过敏</h2><p>环境，即程序运行时的空间与依赖。</p><p>程序运行的依赖环境是很复杂的，而且一般没那么可靠，总是可能出现这样或那样的问题。曾经我经历过一次因为运行环境导致的故障案例：一开始系统异常表现出来的现象是，有个功能出现时不时的不可用；不久之后，系统开始报警，不停地接到系统的报警短信。</p><p>这是一个大规模部署的线上分布式系统，从一开始能感知到的个别系统功能异常到逐渐演变成大面积的报警和业务异常，这让我们陷入了一个困境：到底异常根源在哪里？为了迅速恢复系统功能的可用性，我们先把线上流量切到备用集群后，开始紧急地动员全体团队成员各自排查其负责的子系统和服务，终于找到了原因。</p><p>只是因为有个别服务器容器的磁盘故障，导致写日志阻塞，进程挂起，然后引发调用链路处理上的连锁雪崩效应，其影响效果就是整个链路上的系统都在报警。</p><p>互联网企业多采用普通的 PC Server 作为服务器，而这类服务器的可靠性大约在 99.9%，换言之就是出故障的概率是千分之一。而实际在服务器上，出问题概率最高的可能就是其机械硬盘。</p><p>Backblaze 2014 年发布的硬盘统计报告指出，根据对其数据中心 38000 块硬盘（共存储 100PB 数据）的统计，消费级硬盘头三年出故障的几率是 15%。而在一个足够大规模的分布式集群部署上，比如 Google 这种百万级服务器规模的部署级别上，几乎每时每刻都有硬盘故障发生。</p><p>我们的部署规模自是没有 Google 那么大，但也不算小了，运气不好，正好赶上我们的系统碰上磁盘故障，而程序的编写又并未考虑硬盘 I&#x2F;O 阻塞导致的挂起异常问题，引发了连锁效应。</p><p>这就是当时程序编写缺乏对环境问题的考虑，引发了故障。人有时换了环境，会产生一些从生理到心理的过敏反应，程序亦然。运行环境发生变化，程序就出现异常的现象，我称其为 “程序过敏反应”。</p><p>以前看过一部美剧《豪斯医生》，有一集是这样的：一个手上出现红色疱疹的病人来到豪斯医生的医院，豪斯医生根据病症现象初步诊断为对某种肥皂产生了过敏，然后开了片抗过敏药，吃过后疱疹症状就减轻了。但一会儿后，病人开始出现呼吸困难兼并发哮喘，豪斯医生立刻给病人注射了 1cc 肾上腺素，之后病人呼吸开始变得平稳。但不久后病人又出现心动过速，而且很快心跳便停止了，经过一番抢救后，最终又回到原点，病人手上的红色疱疹开始在全身出现。</p><p>这个剧情中表现了在治疗病人时发生的身体过敏反应，然后引发了连锁效应的问题，这和我之前描述的例子有相通之处：都是局部的小问题，引发程序过敏反应，再到连锁效应。</p><p>过敏在医学上的解释是：“有机体将正常无害的物质误认为是有害的东西。”而我对 “程序过敏反应” 的定义是：“程序将存在问题的环境当作正常处理，从而产生的异常。”而潜在的环境问题通常就成了程序的 “过敏原”。</p><p>该如何应对这样的环境过敏引发的 Bug 呢？</p><h2 id="应对之道"><a href="#应对之道" class="headerlink" title="应对之道"></a>应对之道</h2><p>应对环境过敏，自然要先从 <strong>了解环境</strong> 开始。</p><p>不同的程序部署和运行的环境千差万别，有的受控，有的不受控。比如，服务端运行的环境，一般都在数据中心（IDC）机房内网中，相对受控；而客户端运行的环境是在用户的设备上，存在不同的品牌、不同的操作系统、不同的浏览器等等，多种多样，不可控。</p><p>环境那么复杂，你需要了解到何种程度呢？我觉得你至少必须关心与程序运行直接相关联的那一层环境。怎么理解呢？以后端 Java 程序的运行为例，Java 是运行在 JVM 中，那么 JVM 提供的运行时配置和特性就是你必须要关心的一层环境了。而 JVM 可能是运行在 Linux 操作系统或者是像 Docker 这样的虚拟化容器中，那么 Linux 或 Docker 这一层，理论上你的关心程度就没太多要求，当然，学有余力去了解到这一层次，自是更好的。</p><p>那么前文案例中的磁盘故障，已经到了硬件的层面，这个环境层次比操作系统还更低一层，这也属于我们该关心的？虽说故障的根源是磁盘故障，但直接连接程序运行的那一层，其实是日志库依赖的 I&#x2F;O 特性，这才是我们团队应该关心、但实际却被忽略掉的部分。</p><p>同理，现今从互联网到移动互联网时代，几乎所有的程序系统都和网络有关，所以网络环境也必须是你关心的。但网络本身也有很多层次，而对于在网络上面开发应用程序的你我来说，可以把网络模糊抽象为一个层次，只用关心网络距离延时，以及应用程序依赖的具体平台相关网络库的 I&#x2F;O 特性。</p><p>当然，如果能对网络的具体层次有更深刻的理解，自然也是更好的。事实上，如果你和一个对网络具体层次缺乏理解的人调试两端的网络程序，碰到问题时，经常会发现沟通不在一个层面上，产生理解困难。（这里推荐下隔壁的“趣谈网络协议”专栏）</p><p>了解了环境，也难免不出 Bug。因为我们对环境的理解是渐进式的，不可能一下子就完整掌握，全方位，无死角。当出现了因为环境产生的过敏反应时，收集足够多相关的信息才能帮助快速定位和解决问题，这就是前面《代码与分类》文章中 “运维” 类代码需要提供的服务。</p><p><strong>收集信息</strong>，不仅仅局限于相关直接依赖环境的配置和参数，也包括用户输入的一些数据。真实场景确实大量存在这样一种情况：同样的环境只针对个别用户发生异常过敏反应。</p><p>有一种药叫抗过敏药，那么也可以有一种代码叫 “抗过敏代码”。在收集了足够的信息后，你才能编写这样的代码，因为现实中，程序最终会运行在一些一开始你可能没考虑到的环境中。收集到了这样的环境信息，你才能写出针对这种环境的 “抗过敏代码”。</p><p>这样的场景针对客户端编程特别常见，比如客户端针对运行环境进行的自检测和自适应代码。检测和适应范围包括：CPU、网络、存储、屏幕、操作系统、权限、安全等各方面，这些都属于环境抗过敏类代码。</p><p>而服务端相对环境一致性更好，可控，但面临的环境复杂性更多体现在 “三高” 要求，即：高可用、高性能、高扩展。针对 “三高” 的要求，服务端程序生产运行环境的可靠性并不如你想象的高，虽然平时的开发、调试中你可能很难遇到这些环境故障，但大规模的分布式程序系统，面向失败设计和编码（Design For Failure）则是服务端的 “抗过敏代码” 了。</p><p>整体简单总结一下就是：空间即环境，包括了程序的运行和依赖环境；环境是多维度、多层次的，你对环境的理解越全面、越深入，那么出现空间类 Bug 的几率也就越低；对环境的掌控有广度和深度两个方向，更有效的方法是先广度全面了解，再同步与程序直接相连的一层去深度理解，最后逐层深入，“各个击破”。</p><p>文章开头的第一只飞蛾 Bug，按我的分类就应该属于空间类 Bug 了，空间类 Bug 感觉麻烦，但若单独出现时，相对有形（异常现场容易捕捉）；如果加上时间的属性，就变得微妙多了。</p><p>下一篇，我将继续为你分解 Bug 的时间维度特征。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;12-Bug的空间属性：环境依赖与过敏反应&quot;&gt;&lt;a href=&quot;#12-Bug的空间属性：环境依赖与过敏反应&quot; class=&quot;headerlink&quot; title=&quot;12 | Bug的空间属性：环境依赖与过敏反应&quot;&gt;&lt;/a&gt;12 | Bug的空间属性：环境依赖与过敏</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>13 | Bug的时间属性：周期特点与非规律性</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3400079000.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3400079000.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="13-Bug的时间属性：周期特点与非规律性"><a href="#13-Bug的时间属性：周期特点与非规律性" class="headerlink" title="13 | Bug的时间属性：周期特点与非规律性"></a>13 | Bug的时间属性：周期特点与非规律性</h1><p>在上一篇文章中，我说明了“技术性 Bug 可以从很多维度分类，而我则习惯于从 Bug 出现的 ‘时空’ 特征角度来分类”。并且我也已讲解了Bug 的 <strong>空间维度</strong> 特征：程序对运行环境的依赖、反应及应对。</p><p>接下来我再继续分解 Bug 的 <strong>时间维度</strong> 特征。</p><p>Bug 有了时间属性，Bug 的出现就是一个概率性问题了，它体现出如下特征。</p><h2 id="周期特点"><a href="#周期特点" class="headerlink" title="周期特点"></a>周期特点</h2><p>周期特点，是一定频率出现的 Bug 的特征。</p><p>这类 Bug 因为会周期性地复现，相对还是容易捕捉和解决。比较典型的呈现此类特征的 Bug 一般是资源泄漏问题。比如，Java 程序员都不陌生的 <code>OutOfMemory</code> 错误，就属于内存泄漏问题，而且一定会周期性地出现。</p><p>好多年前，我才刚参加工作不久，就碰到这么一个周期性出现的 Bug。但它的特殊之处在于，出现 Bug 的程序已经稳定运行了十多年了，突然某天开始就崩溃（进程 Crash）了。而程序的原作者，早已不知去向，十多年下来想必也已换了好几代程序员来维护了。</p><p>一开始项目组内经验老到的高工认为也许这只是一个意外事件，毕竟这个程序已经稳定运行了十来年了，而且检查了一遍程序编译后的二进制文件，更新时间都还停留在那遥远的十多年前。所以，我们先把程序重启起来让业务恢复，重启后的程序又恢复了平稳运行，但只是安稳了这么一天，第二天上班没多久，进程又莫名地崩溃了，我们再次重启，但没多久后就又崩溃了。这下没人再怀疑这是意外了，肯定有 Bug。</p><p>当时想想能找出一个隐藏了这么多年的 Bug，还挺让人兴奋的，就好像发现了埋藏在地下久远的宝藏。</p><p>寻找这个 Bug 的过程有点像《盗墓笔记》中描述的盗墓过程：项目经理（三叔）带着两个高级工程师（小哥和胖子）连续奋战了好几天，而我则是个新手，主要负责 “看门”，在他们潜入跟踪分析探索的过程中，我就盯着那个随时有可能崩溃的进程，一崩掉就重启。他们“埋伏”在那里，系统崩溃后抓住现场，定位到对应的源代码处，最后终于找到了原因并顺利修复。</p><p>依稀记得，最后定位到的原因与网络连接数有关，也是属于资源泄漏的一种，只是因为过去十来年交易量一直不大且稳定，所以没有显现出来。但在我参加工作那年（2006年），中国股市悄然引来一场有史以来最大的牛市，这个处理银行和证券公司之间资金进出的程序的“工作量”突然出现了爆发性增长，从而引发了该 Bug。</p><p>我可以理解上世纪九十年代初那个编写该服务进程的程序员，他可能也难以预料到当初写的用者寥寥的程序，最终在十多年后的一天会服务于成百上千万的用户。</p><p>周期性的 Bug，虽然乍一看很难解决的样子，但它总会重复出现，就像可以重新倒带的 “案发现场”，找到真凶也就简单了。案例中这个 Bug 隐藏的时间很长，但它所暴露出的周期特点很明显，解决起来也就没那么困难。</p><p>其实主要麻烦的是那种这次出现了，但不知道下次会在什么时候出现的 Bug。</p><h2 id="非规律性"><a href="#非规律性" class="headerlink" title="非规律性"></a>非规律性</h2><p>没有规律性的 Bug，才是让人抓狂的。</p><p>曾经我接手过一个系统，是一个典型的生产者、消费者模型系统。系统接过来就发现一个比较明显的性能瓶颈问题，生产者的数据源来自数据库，生产者按规则提取数据，经过系统产生一系列的转换渲染后发送到多个外部系统。这里的瓶颈就在数据库上，生产能力不足，从而导致消费者饥饿。</p><p>问题比较明显，我们先优化 SQL，但效果不佳，遂改造设计实现，在数据库和系统之间增加一个内存缓冲区从而缓解了数据库的负载压力。缓冲区的效果，类似大河之上的堤坝，旱时积水，涝时泄洪。引入缓冲区后，生产者的生产能力得到了有效保障，生产能力高效且稳定。</p><p>本以为至此解决了该系统的瓶颈问题，但在生产环境运行了一段时间后，系统表现为速度时快时慢，这时真正的 Bug 才显形了。</p><p>这个系统有个特点，就是 I&#x2F;O 密集型。消费者要与多达 30 个外部系统并发通信，所以猜测极有可能导致系统性能不稳定的 Bug 就在此，于是我把目光锁定在了消费者与外部系统的 I&#x2F;O 通信上。既然锁定了怀疑区域，接下来就该用证据来证明，并给出合理的解释原因了。一开始假设在某些情况下触碰到了阈值极限，当达到临界点时程序性能则急剧下降，不过这还停留在怀疑假设阶段，接下来必须量化验证这个推测。</p><p>那时的生产环境不太方便直接验证测试，我便在测试环境模拟。用一台主机模拟外部系统，一台主机模拟消费者。模拟主机上的线程池配置等参数完全保持和生产环境一致，以模仿一致的并发数。通过不断改变通信数据包的大小，发现在数据包接近 100k 大小时，两台主机之间直连的千兆网络 I&#x2F;O 达到满负载。</p><p>于是，再回头去观察生产环境的运行状况，当一出现性能突然急剧下降的情况时，立刻分析了生产者的数据来源。其中果然有不少大报文数据，有些甚至高达 200k，至此基本确定了与外部系统的 I&#x2F;O 通信瓶颈。解决办法是增加了数据压缩功能，以牺牲 CPU 换取 I&#x2F;O。</p><p>增加了压缩功能重新上线后，问题却依然存在，系统性能仍然时不时地急剧降低，而且这个时不时很没有时间规律，但关联上了一个 “嫌疑犯”：它的出现和大报文数据有关，这样复现起来就容易多了。I&#x2F;O 瓶颈的怀疑被证伪后，只好对程序执行路径增加了大量跟踪调试诊断代码，包含了每个步骤的时间度量。</p><p>在完整的程序执行路径中，每个步骤的代码块的执行时间独立求和结果仅有几十毫秒，最高也就在一百毫秒左右，但多线程执行该路径的汇总平均时间达到了 4.5 秒，这比我预期值整整高了两个量级。通过这两个时间度量的巨大差异，我意识到线程执行该代码路径的时间其实并不长，但花在等待 CPU 调度的时间似乎很长。</p><p>那么是 CPU 达到了瓶颈么？通过观察服务器的 CPU 消耗，平均负载却不高。只好再次分析代码实现机制，终于在数据转换渲染子程序中找到了一段可疑的代码实现。为了验证疑点，再次做了一下实验测试：用 150k 的线上数据报文作为该程序输入，单线程运行了下，发现耗时居然接近 50 毫秒，我意识到这可能是整个代码路径中最耗时的一个代码片段。</p><p>由于这个子程序来自上上代程序员的遗留代码，包含一些稀奇古怪且复杂的渲染逻辑判断和业务规则，很久没人动过了。仔细分析了其中实现，基本就是大量的文本匹配和替换，还包含一些加密、Hash 操作，这明显是一个 CPU 密集型的函数啊。那么在多线程环境下，运行这个函数大概平均每个线程需要多少时间呢？</p><p>先从理论上来分析下，我们的服务器是 4 核，设置了 64 个线程，那么理想情况下同一时间可以运行 4 个线程，而每个线程执行该函数约为 50 毫秒。这里我们假设 CPU 50 毫秒才进行线程上下文切换，那么这个调度模型就被简化了。第一组 4 个线程会立刻执行，第二组 4 个线程会等待 50 毫秒，第三组会等待 100 毫秒，依此类推，第 16 组线程执行时会等待 750 毫秒。平均下来，每组线程执行前的平均等待时间应该是在 300 到 350 毫秒之间。这只是一个理论值，实际运行测试结果，平均每个线程花费了 2.6 秒左右。</p><p>实际值比理论值慢一个量级，这是为什么呢？因为上面理论的调度模型简化了 CPU 的调度机制，在线程执行过程的 50 毫秒中，CPU 将发生非常多次的线程上下文切换。50 毫秒对于 CPU 的时间分片来说，实在是太长了，因为线程上下文的多次切换和 CPU 争夺带来了额外的开销，导致在生产环境上，实际的监测值达到了 4.5 秒，因为整个代码路径中除了这个非常耗时的子程序函数，还有额外的线程同步、通知和 I&#x2F;O 等操作。</p><p>分析清楚后，通过简单优化该子程序的渲染算法，从近 50 毫秒降低到 3、4 毫秒后，整个代码路径的线程平均执行时间下降到 100 毫秒左右。收益是明显的，该子程序函数性能得到了 10 倍的提高，而整体执行时间从 4.5 秒降低为 100 毫秒，性能提高了 45 倍。</p><p>至此，这个非规律性的 Bug 得到了解决。</p><p>虽然案例中最终解决了 Bug，但用的方法却非正道，更多依靠的是一些经验性的怀疑与猜测，再去反过来求证。这样的方法局限性非常明显，完全依赖程序员的经验，然后就是运气了。如今再来反思，一方面由于是刚接手的项目，所以我对整体代码库掌握还不够熟悉；另一方面也说明当时对程序性能的分析工具了解有限。</p><p>而更好的办法就应该是采用工具，直接引入代码 Profiler 等性能剖析工具，就可以准确地找到有性能问题的代码段，从而避免了看似有理却无效的猜测。</p><p>面对非规律性的 Bug，最困难的是不知道它的出现时机，但一旦找到它重现的条件，解决起来也没那么困难了。</p><h2 id="神出鬼没"><a href="#神出鬼没" class="headerlink" title="神出鬼没"></a>神出鬼没</h2><p>能称得上神出鬼没的 Bug 只有一种： <strong>海森堡 Bug（Heisenbug）</strong>。</p><p>这个 Bug 的名字来自量子物理学的 “海森堡不确定性原理”，其认为观测者观测粒子的行为会最终影响观测结果。所以，我们借用这个效应来指代那些无法进行观测的 Bug，也就是在生产环境下不经意出现，费尽心力却无法重现的 Bug。</p><p>海森堡 Bug 的出现场景通常都是和分布式的并发编程有关。我曾经在写一个网络服务端程序时就碰到过一次海森堡 Bug。这个程序在稳定性负载测试时，连续跑了十多个小时才出现了一次异常，然后在之后的数天内就再也不出现了。</p><p>第一次出现时捕捉到的现场信息太少，然后增加了更多诊断日志后，怎么测都不出现了。最后是怎么定位到的？还好那个程序的代码量不大，就天天反复盯着那些代码，好几天过去还真就灵光一现发现了一个逻辑漏洞，而且从逻辑推导，这个漏洞如果出现的话，其场景和当时测试发现的情况是吻合的。</p><p>究其根源，该 Bug 复现的场景与网络协议包的线程执行时序有关。所以，一方面比较难复现，另一方面通过常用的调试和诊断手段，诸如插入日志语句或是挂接调试器，往往会修改程序代码，或是更改变量的内存地址，或是改变其执行时序。这都影响了程序的行为，如果正好影响到了 Bug，就可能诞生了一个海森堡 Bug。</p><p>关于海森堡 Bug，一方面很少有机会碰到，另一方面随着你编程经验的增加，掌握了很多编码的优化实践方法，也会大大降低撞上海森堡 Bug 的几率。</p><p>综上所述，每一个 Bug 都是具体的，每一个具体的 Bug 都有具体的解法。但所有 Bug 的解决之道只有两类：事后和事前。</p><p>事后，就是指 Bug 出现后容易捕捉现场并定位解决的，比如第一类周期特点的 Bug。但对于没有明显重现规律，甚至神出鬼没的海森堡 Bug，靠抓现场重现的事后方法就比较困难了。针对这类 Bug，更通用和有效的方法就是在事前预防与埋伏。</p><p>之前在讲编程时说过一类代码：运维代码，它们提供的一种能力就像人体血液中的白细胞，可以帮助发现、诊断、甚至抵御 Bug 的 “入侵”。</p><p>而为了得到一个更健康、更健壮的程序，运维类代码需要写到何种程度，这又是编程的 “智慧” 领域了，充满了权衡选择。</p><p>程序员不断地和 Bug 对抗，正如医生不断和病菌对抗。不过Bug 的存在意味着这是一段活着的、有价值的代码，而死掉的代码也就无所谓 Bug 了。</p><p>在你的程序员职业生涯中，有碰到过哪些有意思的 Bug呢？欢迎你给我留言分享讨论。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;13-Bug的时间属性：周期特点与非规律性&quot;&gt;&lt;a href=&quot;#13-Bug的时间属性：周期特点与非规律性&quot; class=&quot;headerlink&quot; title=&quot;13 | Bug的时间属性：周期特点与非规律性&quot;&gt;&lt;/a&gt;13 | Bug的时间属性：周期特点与非规</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>22 | 领域：知识与体系</title>
    <link href="https://zhuansun.github.io/geekbang/posts/2583833674.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/2583833674.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="22-领域：知识与体系"><a href="#22-领域：知识与体系" class="headerlink" title="22 | 领域：知识与体系"></a>22 | 领域：知识与体系</h1><p>今年年初，我学习了梁宁的《产品思维》课，其中有一篇叫《点线面体的战略选择》，我觉得特别有感触。虽然是讲产品，但假如把个人的成长当成产品演进一样来发展，会有一种异曲同工、殊途同归之感。</p><p>在我工作的经历中就曾碰到过这么一个人，他一开始做了几年开发，从前端到后端，后来又转做测试，接触的“点”倒是不少，但却没能连接起来形成自己的体系，那他个人最大的价值就局限在最后所在的“点”上了。</p><p>其实个人的成长有很多方面，但对于程序员的成长最重要的就是知识体系的构建，这其实就是一个 “点线面体” 的演进过程。</p><p>下面我会结合自己的成长路线来梳理下这个体系的建立过程。</p><h2 id="点"><a href="#点" class="headerlink" title="点"></a>点</h2><p>进入任何一个知识领域，都是从一个点开始的。</p><p>如下图，是我从大学进入软件开发领域所接触的一系列的点，我将其从左到右按时间顺序排列。红色的部分是目前还属于我 “掌握” 与 “了解” 的领域，其他灰色的部分则是要么被时代淘汰了，要么已经被我放弃了维持与更新。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/638714dc6079ed98aca692b6e9f9aaff.png"></p><p>我的成长时间线上相关技术领域知识点</p><p>我入行的年代，流行的是 C&#x2F;S 架构的软件开发模型。当时客户端开发三剑客是 PB（PowerBuilder）、VB（Visual Basic）和 Delphi，而我只是顺势选了其中的一两个点，然后开启了程序员生涯。</p><p>没过两年B&#x2F;S 架构开始流行，并逐步取代了 C&#x2F;S 架构。于我，只是因为研究生阶段学校开了一门面向对象语言课，老师用 Java 做教学语言，所以我后来就又顺势成了一名 Java 程序员。而又只是因为 Java 的生命力特别旺盛，所以也就延续至今。</p><p>早些年，前后端还没太分离时，因为项目需要，所以我又去涉猎了一些前端 JS 开发；之后移动互联网崛起，又去学习了些移动开发的东西；再之后就是 ABC 的时代（其中 A 是 AI ，人工智能；B 是 Big Data，大数据；C 是 Cloud，云计算），就又被潮流裹挟去追逐新的技术浪潮。</p><p>如今回过头再看，每一个技术点，似乎都是自己选择的，但又感觉只是一种被趋势推动的一次次无意“捡起”。有些点之间有先后的承接关系，而更多点都慢慢变成了孤点，从这片技术的星空中暗淡了下去。</p><p>在你入行后，我想你可能也会因为时代、公司或项目的原因，有很大的随机性去接触很多不同的技术点。但如果你总是这样被客观的原因驱动去随机点亮不同的 “点”，那么你终究会感到有点疲于奔命，永远追不上技术的浪潮。</p><h2 id="线"><a href="#线" class="headerlink" title="线"></a>线</h2><p>当形成的点足够多了后，一部分点开始形成线，而另一些点则在技术趋势的演进中被自然淘汰或自己主动战略放弃。</p><p>那你到底该如何把这些零散的点串成线，形成自己的体系与方向呢？如下图，是我的一个成长 “T 线图”，它串联了如今我沉淀下来的和一些新发展的 “点”。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/f5d13b580da5d58e38423885b2020e7b.png"></p><p>我个人的成长发展 “T 线图”</p><p>我从成为了一名 Java 程序员开始，在这条 “T线” 上，先向下走，专注于解决业务需求碰到的技术问题。先自然地要向下至少走一层，接触 Java 的运行平台 JVM。而又因为早期做了几年电信项目，要和很多网络设备（包括各类网元和交换机等）通信，接触网络协议编程；后来又做了即时消息（IM）领域的工作，网络这一块就又继续增强了。而网络编程依赖于操作系统提供的 I&#x2F;O 模型和 API，自然绕不过 OS 这一块。</p><p>在 Java 领域走了多年以后，以前涉猎的技术点就逐步暗淡了。而再从程序员到架构师，就开始往上走，进入更纯粹的 “架构与设计” 领域，在更宽的范围和更高的维度评估技术方案，做出技术决策与权衡，设定技术演进路线。</p><p>但是，再好的技术方案，再完美的架构，如果没有承载更有意义的业务与产品形态，它们的价值和作用就体现不了。所以不可避免，再往上走时就会去了解并评估 “业务与产品”，关注目标的价值、路径的有效性与合理性。</p><p>在整个纵向的技术线上，最终汇总到顶点，会形成一种新的能力，也就是我对这条纵向线的 “掌控力”。到了这个 “点” 后，在这里可以横向发展，如图中，也就有了新的能力域：领导力和组织力。</p><p>一个个点，构成了基本的价值点，这些点串起来，就形成了更大的价值输出链条。在这条路上，你也会有一条属于自己的 “T线”，当这条线成型后，你的价值也将变得更大。</p><h2 id="面"><a href="#面" class="headerlink" title="面"></a>面</h2><p>线的交织，将形成面。</p><p>当我试着把我最近六年多在电商客服和即时通讯领域的工作画出来后，它就织就了下面（如图所示）的这个“面”。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/5cfaffafd4b327b9b9dbf48725cd2dce.png"></p><p>我近些年工作面的分层图</p><p>我从最早的聚焦于某个业务点和技术栈，逐步延伸扩展到整个面。因为 IM 这个产品本身具备很深的技术栈，而且也有足够多元化的应用场景，这样整个面就可以铺得特别宽广。这也是为什么我已经在这个面上耕耘了六年多之久。</p><p>但事实上，我并不掌握这个面上的每个点，整个团队才会分布工作在整个面上，每个个体贡献者也只会具体工作在这个面上的某个或某些点。但我们需要去认清整个面的价值体系，这样才能更好地选择和切入工作的点，创造更大的价值。</p><p>而有时候，我也了解到有些程序员的一些说法是这样的：在相对传统的行业，做偏业务的开发，技术栈相对固定且老化，难度和深度都不高，看不到发展方向，期望找到突破口。若你也出现这样的情况，那就说明你从事的业务开发，其单个技术点的价值上限较低，而选择更新、更流行的技术，你就是期望提升单个技术点的价值，但单个技术点的价值是相对有限的。</p><p>反过来，如果很难跳脱出自身环境的局限，那么也可以不局限于技术，去考虑这些传统的业务价值，从技术到业务，再上升到用户的接入触达，考虑产品的场景、形态和人群是如何去为这些用户提供的服务、产生的价值。</p><p>当你对整个业务面上的价值点掌握的更多，能抓住和把握核心的价值链条，去为更广、更大的价值负责，那么你就能克服自己的成长发展困境，找到了另外一条出路了。</p><p>同时，你也为自己织就了一张更大的领域之网。在整个面形成了一个领域，在这个面上你所能掌控的每条线就是你的体系。在这条线的 “点” 上，你解决具体问题，是做解答题；但在整个面上你选择 “线”，是做选择题。</p><h2 id="体"><a href="#体" class="headerlink" title="体"></a>体</h2><p>体是经济体或其中的单元。</p><p>你的 “面” 附着在什么 “体” 上决定了它的价值上限。如果 “体” 在高速增长并形成趋势，你就可能获得更快的发展。</p><p>从电力时代到信息时代再到智能时代，互联网、电商、移动互联网，这些都是 “体” 的变化。今天互联网行业的软件工程师，他们面临的挑战和难度不见得比传统的机械或电力工程师更大，只不过他们所从事的 “点” 所属的 “面”，附着于一个快速崛起的 “体” 上，获得了更大的加速度。</p><p>“体” 的崛起，是时代的机遇。</p><p>总结来说，就是： <strong>在领域知识体系中，“点” 是利器，“线” 是路径，“面” 是地图；而就我们个体而言，“点” 是孤立知识点的学习掌握，而 “线” 是对这些点的连接，“面” 则构成了完整的知识体系网</strong>。</p><p>以上就是我建立知识体系并形成自己领域的思考。而在每个不同的阶段，你都可以先做到心中有图，再来画“线”，然后再在每个“点”上去努力。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;22-领域：知识与体系&quot;&gt;&lt;a href=&quot;#22-领域：知识与体系&quot; class=&quot;headerlink&quot; title=&quot;22 | 领域：知识与体系&quot;&gt;&lt;/a&gt;22 | 领域：知识与体系&lt;/h1&gt;&lt;p&gt;今年年初，我学习了梁宁的《产品思维》课，其中有一篇叫《点线面</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>21 | 信息：过载与有效</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3186636997.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3186636997.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="21-信息：过载与有效"><a href="#21-信息：过载与有效" class="headerlink" title="21 | 信息：过载与有效"></a>21 | 信息：过载与有效</h1><p>至此，专栏已用6篇文章讲完了我关于“计划体系”这个主题的理解与思考 ，你是不是已经有点按捺不住想要赶快上路实践了？不急，接下来分享的主题是关于 “精进思维” 的，它会让你在按计划上路时，会有更好的跑步姿态，从而跑得更轻松、更有效率。</p><p>在我刚开始学编程时，国内还没有互联网，去到书店，发现偌大的书店就只能找到两本关于程序语言的书。那时感觉，想学点新东西，信息真是相当匮乏。而现如今，国内互联网已经发展了二十余年，信息早已不再匮乏，甚至是到了让人感觉过载的时代。</p><h2 id="现状：信息过载"><a href="#现状：信息过载" class="headerlink" title="现状：信息过载"></a>现状：信息过载</h2><p>信息时代，作为离信息距离最近的职业之一，程序员应该最能感受这个时代的信息洪流与知识迭代的速度有多快。</p><p>据 IDC（国际数据公司）研究报告：现在每 48 小时所产生的数据量，相当于从人类文明开始到 2003 年累计的数据总量。而每年产生的信息数据量还在不断增长，但我们处理信息的能力，特别是大脑接收信息，并将其消化为知识的能力，这么多年来并没有多少提升。</p><p>信息数据量的高速增长，也带来了处理信息技术的快速发展，所以新技术层出不穷，而且现有的技术也开始在其深度和广度领域不断地开疆拓土。</p><p>这样的发展状况说明了一个现实：我们没办法掌握这一切。别说“一切”，其实更符合实际的情况是，我们仅仅掌握了已有信息和知识领域中非常微小的一部分。</p><p>在信息大爆炸的时代，我们对信息越发敏锐，信息就越会主动吸引我们，让我们产生一种过载的感觉。</p><h2 id="状态：疲于奔命"><a href="#状态：疲于奔命" class="headerlink" title="状态：疲于奔命"></a>状态：疲于奔命</h2><p>在面对这股信息与知识的洪流时，有时我们会不自觉地就进入到了 “疲于奔命”模式中。</p><p>因为每天感觉有太多的信息要处理，太多的知识想学习。计划表排得满满的，似乎每天没能完成当天的计划，就会产生焦虑感，造成了日复一日的 “疲于奔命” 状态。</p><p>曾经，我就处在过这样的状态中，逼得过于紧迫，再奔命也只能被这股洪流远远抛下。总是焦虑着完成更多，划掉 TODO List 上更多的事项，希望每日带着超额完成计划的充实与满足感入睡，最后这一切不过是一种疲于奔命带来的虚幻满足感。</p><p>如今算是搞清楚了，这种紧绷的状态并不利于我们的学习和成长，这可以从大脑工作的生理机制得到侧面的佐证。</p><p>2017 年 2 月，国外著名《科学》期刊发表的一个研究成果表明，我们的大脑中存在约 860 亿神经元，神经元之间会形成连接，连接的点有个专有名词：突触，而每个神经元会和别的神经元形成大约 1000 个突触；大脑不断接收并输入信息，突触就会变强大，体积也会变大。但突触不能无限加强、变大，要不然就会饱和，甚至 “烧毁”，这就是大脑生理层面的 “信息过载”。</p><p>突触饱和了，再继续摄入和接收信息，此时我们就很难再学习到并留存下新的东西了，所以为了保持大脑学习新事物的能力，就必须要休息，而最好的休息则是睡眠。在睡眠中，突触会被修剪，神经连接会被削弱。美国威斯康星大学麦迪逊分校的两位研究者发现，睡觉的时候，大脑里的突触会缩小将近 20%。</p><p>所以，在感觉大脑处于 “过载” 的疲倦中时，别“疲于奔命”，别硬撑，最好的办法就是去小憩片刻。</p><p>记得大学时代，那时喜欢玩组装机 DIY。当时穷，买不起或舍不得买高配的 CPU，就买低配的 CPU，然后自己跳线超频，让 CPU 工作在过载状态中。然后弄个软件，再跑个分，一种妥妥的性价比超高的满足感。</p><p>而大脑的工作模式就有点像 CPU，而人只要活着，大脑会一直工作，从不停止。</p><p>即使我们感觉并没有使用大脑，我们的大脑也会处于一种 “默认模式网络” 状态。这可类比于电脑 CPU 的空闲（Idle）模式：电脑 CPU 倒是可以进入接近100%的空闲，但大脑不会，它最低也会保持 20% 左右的利用率，即便我们在睡眠中。</p><p>在 “默认模式网络” 下，大脑还会有 20% 左右的利用率，它在做什么？实际上，这个状态下，大脑会去发掘过去的记忆，去畅想未来，在过去和未来之间建立连接。而在生理层面，大脑中会有新的神经连接形成，这样的新连接，就是我们创造力的来源。</p><p>进入了疲于奔命状态，其实我们就在不断给大脑喂任务，且不停地切换大脑任务，让它永远处于繁忙甚至超频状态。这样每个任务的执行效率都会下降且效果也不佳，所以导致执行任务的时间反而延长了，这就给我们营造了一种“忙碌、充实而疲倦”的虚幻假象。</p><p>人脑毕竟不是 CPU，它需要休息，持续的过载与奔命，并不能让我们学会更多，但却会减少我们创造新的可能。</p><h2 id="筛选：心智模型"><a href="#筛选：心智模型" class="headerlink" title="筛选：心智模型"></a>筛选：心智模型</h2><p>面对大量的信息和知识，我们该如何应对？这可以从两个角度来考虑：</p><ul><li>信息和知识本身的价值</li><li>我需要怎样的信息和知识</li></ul><p>第一点，信息和知识的价值是一个主观的判断，有一个客观点的因子是获取门槛。如果一个信息或知识随处可得，大家都能接触到，甚至变得很热门，那么其价值可能就不大。吴军老师有一篇文章讲了个道理叫：“众利勿为，众争勿往”，这在对信息和知识价值的主观判断上也是通用的。</p><p>第二点，就提出了一个关于如何筛选信息和知识的问题。心理学上有一个 “心智模型” ：</p><blockquote><p>“心智模型” 是用于解释个体对现实世界中某事所运作的内在认知历程，它在有限的领域知识和有限的信息处理能力上，产生合理的解释。</p></blockquote><p>每个人都有这样的 “心智模型”，用来处理信息，解释行为，做出决策。不过只有少部分人会更理性地认知到这个模型的存在，而且不断通过吸收相关信息和知识来完善这个模型；更多的众人依赖的是所谓的 “感觉” 和 “直觉”。但实际上 “感觉” 和 “直觉” 也是 “心智模型” 产生的一种快捷方式，只是他们没有理性地认知到这一点。</p><p>理解了如上对 “心智模型” 的描述，是不是感觉它和如今人工智能领域的机器学习模型有点异曲同工之处？我们可以将这两者作以类比。它们都是接收信息和数据，得到模型，再对未知做出预测和判断。只不过人的 “心智模型” 却又比现在所有的人工智能模型都高级，高级到如今还无法用科学来清晰地描述与解释清楚。</p><p>理解了以上两点，再把大量的信息和知识限定在我们所处的程序领域，就会得到一个合理的答案。</p><p>当我刚进入程序员这行时，就一直存在有关 “超级程序员” 的传说，似乎 “超级程序员” 无所不能，各种语言信手拈来，所到之处，Bug 都要退避三舍。江湖总有他们的传闻，但谁也没见过。</p><p>后来慢慢开始明白了，那些 “超级程序员” 也仅仅是在一两个专业知识领域深耕的年头比较久，做出了一些脍炙人口且享誉程序界的好作品，他们在其专业领域拥有精深的专业知识和技能，同时也有大量通用的一般知识储备，适用于跨专业范围的程序领域中。因此，在这个信息过载的洪流中，需要的就是在这股洪流中筛选信息并建立自己中流砥柱般的 “知识磐石”。</p><p>“心智” 这两个字合在一起是一个意思，分开为 “心” 和 “智” 两个字又可以分别解释为： <strong>“心” 是你对需要的选择，从心出发；“智” 是对价值的判断，智力的匹配</strong>。</p><h2 id="应用：一击中的"><a href="#应用：一击中的" class="headerlink" title="应用：一击中的"></a>应用：一击中的</h2><p>储备了信息，建立了知识，最终都是为了应用。</p><p>囤积信息，学习知识，如果不能被应用在改变自己上，那还有什么意义？</p><p>没有目的的学习是徒劳的，它仅仅是在我们的头脑中流过一遍，流过的痕迹很快又会被新的信息冲刷干净。不管我们拥有怎样的 “最强大脑”，在面对这股信息与知识洪流时，都几乎可忽略不计。</p><p>大脑确实和计算机的 CPU 有很多类似之处，比如它也有一个缓存单元：长短期记忆，类似 CPU 的多级缓存；它还有一个计算单元，用于任务处理与决策。这让我联想到像 Java JVM 的实现中有一种实时编译技术叫 JIT（Just-In-Time），它会根据代码的调用量来决定是否进行编译执行。而对于知识学习，我们也可以采用类似的策略，到底哪些知识需要提前编译储备在大脑中，哪些仅在特定场景触发下才需要 “实时编译”去边学边用。</p><p>毕竟未来充满了太多的未知和意外，我们没法提前储备太多。</p><p>而前文也提到大脑不适合长期持续地满负荷运转，这与我自己的真实感受是一致的。我感觉如果一次性让大脑满负荷（100%）运转达到 4 小时左右，就会感到很疲劳。而做不同的事情对大脑的利用率是不同的，下图结合自身感受画出了一个我自己的大脑消耗率示意图：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/a5c64ac7e7b9392993a40147ef5550bf.png"></p><p>所以，这里就要有选择和取舍。万维钢的一篇文章中有句话是这么说的：</p><blockquote><p>注意力是一种有限的资源，你要是不擅长不集中注意力，你就不擅长集中注意力。</p></blockquote><p>你得挑选那些真正值得做和学的东西去让大脑满负荷运转，但凡投入决心去做的事情，就需要百分百投入。这就是专注于少而精的东西，深入了解这些东西，进入到更深的层次上。深可以无止境，那到底多深才合适？我的答案是： <strong>让你的内心对取得的效果感受到满意的深度层次上</strong>。它的反面是：但凡心存疑虑，不是那么确定要全力投入的事情，干脆就不做了。</p><p>以前写一篇文章，我会给一个合理的时限要求。比如高考作文 800 字，要在 50 ～ 60 分钟内完成。而我每篇文章一般在 2000 ～ 3000 字，我给的时限也就在 3 小时左右。因为安排了这 3 小时，其他时间按计划还要干别的，但这个安排一直让我很焦虑，因为经常性写超时。</p><p>现在明白了，写作本来是一件创造性的活动，一件 “脑耗率” 100% 的活动，需要百分百的投入，最终效果远重于时限。即便我在 2 小时写完了，但效果能达到让我内心取得满意的深度层次么？（题外话，每篇专栏文章的写作和反复修改，平均要 6 ～ 10 小时。）</p><p>做得多和做得好的感觉很不一样。就像拳击，多，好似不停挥拳，很快就精疲力竭；好，则是看准目标，抓住机会全力出击，一击中的。</p><p>最后，总结下在信息爆炸的时代，我们该如何有效处理、吸收和消化信息：</p><ul><li>信息过载是现实；</li><li>疲于奔命是陷阱；</li><li>心智模型是方法；</li><li>一击中的是策略。</li></ul><p>那关于信息处理的有效方法和模型，你目前采用的是怎样的好办法呢？欢迎留言分享，我们相互学习下。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;21-信息：过载与有效&quot;&gt;&lt;a href=&quot;#21-信息：过载与有效&quot; class=&quot;headerlink&quot; title=&quot;21 | 信息：过载与有效&quot;&gt;&lt;/a&gt;21 | 信息：过载与有效&lt;/h1&gt;&lt;p&gt;至此，专栏已用6篇文章讲完了我关于“计划体系”这个主题的理解</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>23 | 转化：能力与输出</title>
    <link href="https://zhuansun.github.io/geekbang/posts/1366585641.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/1366585641.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="23-转化：能力与输出"><a href="#23-转化：能力与输出" class="headerlink" title="23 | 转化：能力与输出"></a>23 | 转化：能力与输出</h1><p>个人，建立好了知识体系，各方面都明了了，但有时做起事来却还会感觉发挥不出来；团队，牛人众多，但感觉做出的事情效果却很一般。</p><p>这类问题的症结，多就出在从体系积累到输出转化的环节，它涉及两个实体的转化问题：</p><ul><li>个体</li><li>团队</li></ul><h2 id="个体"><a href="#个体" class="headerlink" title="个体"></a>个体</h2><p>关于个体的能力转化，我想先讲一个发生在我自己身上的故事，通过类比想必你就能很快明白这个道理。</p><p>前几年有几部华语电影，比如《叶问》《一代宗师》等，都是和一个人、一套功夫有关；而从前年到去年的一段时间，在我身上正好就发生了这么一件计划外的事情，我去接触学习了一下咏春。练拳这个事，一开始就不在我计划内，甚至也不算是兴趣内的事，但它就这么发生了，然后还意外地让我有了一些收获。</p><p>在刚开始时，我的确对咏春有很多疑惑，但好在并不排斥。一开始老师并没有教什么招式套路，而是从架构开始。既然是功夫，当然这个 “架构” 就是指身体架构了。为什么不讲招式，而是讲架构？这也是我最初的疑惑。随后，老师用一个生动的示例说明了缘由。</p><p>老师先拿上一个挡在胸前上的沙包，让我们挥拳全力击打，他来挡住。然后我们就全力挥拳了，阵势倒是挺大，打在沙包上也砰砰脆响，但老师纹丝不动。反过来，该我拿沙包挡在胸前了，老师出拳，拳头接触沙包后发出沉闷的响声，我用尽全身力气也站不住，连连后退，直到碰到墙边才止住退势，并且胸口还隐隐作痛。</p><p>好吧，以上描写，有点武侠小说的感觉了，但实际并无夸张。以后每次老师演示沙包架构教学，各位同学都连连谦让起来。这里面的原理后来听老师讲解才算明了：我们平常出拳基本都是用的臂力，力量不会太大；而老师出拳用的是身体之力，借助身体架构发全身之力。</p><p>力，从脚底触地而起，由腿上腰，扭腰推至背肩，再甩肩推臂，经腕至拳，最后触及被击打之物。在这个过程中，全身都会随这股力量而动，借助全身体重的推动力，会大幅度地放大这股力量。这股力量甚至超过了他的体重，试想一个成年人那么重的力量推向你，你如何能接得住？</p><p>后来，我了解到，经过职业训练的拳击手，正常挥出重拳的力量可以是体重的好几倍。而我们普通人挥拳只用手臂发力，只有体重的几分之一。因为我们没有经过身体架构的训练，所以身体架构各自配合脱节，力量便耗散在了过程之中，而发不出全身之力。</p><p>身体是一个系统，身体架构是一个体系，这个体系的输出能力便是出拳的力量。</p><p>要放大这个力量，就需要不断反复地去协调应用这个体系，并不断得到反馈修正，最后形成肌肉记忆的习惯，就像老师一挥拳就能爆发全身之力一样。而我练习了几个月，估计也没到半身之力，这个过程和所有技能的刻意练习过程一样，快不了。</p><p>同理，我们从学会一个知识，到能够熟练应用其去输出能力，大概会经历如下过程：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/f7dc81387177314594fc40618eb94bd6.png"></p><p>所以，对于个体而言，刚建立起一个初步的知识体系，到能真正充分发挥出这个体系的力量，才仅仅是刚开始。</p><h2 id="团队"><a href="#团队" class="headerlink" title="团队"></a>团队</h2><p>如果说个体的能力输出像出拳，那么团队的输出就像战争了。</p><p>在近年来大热的美剧《权力的游戏》中，一开始有两个家族，北方的狼家族和南方的狮家族，他们爆发了一场战争。战争之初，狼家族在战场上连战连胜，甚至一度俘虏了狮家族的重要人物，但后来突然急转直下，竟被人在战场之外全灭。</p><p>而战争其实是发生在两个体系（这里的体系是国家、家族和部落）之间的能力较量。每一个战场、每一场战役仅仅是体系中一些“点”的较量，虽然北境的狼家族一开始在战场上连连获胜，但他们这个内部体系的薄弱环节和问题远多于狮家族这个体系，因而在被人抓住关键节点后，一下就瓦解了。</p><p>团队这个体系比较复杂，即使个体的点很强，但仅仅是点的强化，也有可能不断赢了战役，但最后却输了整个战争。</p><p>去年也有一本大热的翻译书籍《原则》，该书的作者是雷·达里奥，他是世界最大对冲基金——桥水联合基金——的创始人。这本书描述了他的一个思想和实践，就是把公司当作 “机器” （原文是 Machine）来管理运转。</p><p>所以，在他看来管理者就像是工程师，而工程师维护机器运转的工作状态我们都能想象到，或通过机器的运行仪表盘监控机器的运转状态，或通过指标优化机器的运行效率。而达里奥的 “机器” 就是他建立的管理公司的体系。</p><p>曾经，我们团队有个高级测试工程师，在他晋升测试架构师级别的述职时，提到他的一项工作就是搭建测试体系来帮助团队改善测试工作的效率和效果。在进行阐述时，他完整地描述了这个体系 “机器” 的各个零部件组成，他制造的很多工具和系统，却缺失了关于体系的一些最重要的方面：这个体系是如何运转的？它提供了哪些系统和仪表盘监控指标来支撑和反映其运转状态？为什么这个体系能在团队里运转？</p><p>以上三个问题，就反映了 “机器” 体系的三个核心点：</p><ul><li>流程规则</li><li>工具系统</li><li>规范共识</li></ul><p>没有流程规则，“机器” 体系就不知该如何运转；缺乏工具系统支撑，就没法监视和控制这个体系的运转效率与效果；而如果未能在团队形成共识并达成规范，“机器” 体系就不可能“和谐”运转起来。所以，流程规则，建立其运行轨道；工具系统，支撑其高效运行；规范共识，形成了协调合奏。</p><p>团队能力输出就是这样一个 “机器” 体系运行的过程。那么团队的强弱就由两方面决定，一是团队中所有个体形成的体系力量之和，二是由流程规则、工具系统和规范共识共同决定的转化效率。</p><h2 id="转化"><a href="#转化" class="headerlink" title="转化"></a>转化</h2><p>从个体到团队，都是通过搭建体系来积蓄力量，再通过体系的运转来输出能力。</p><p>这里的共同思维方式是：体系化、工具化。这是一种标准的工程师思维模式，巧妙的是它依然可以用在非工程的领域。体系，从工程维度看就像生产流水线，而体系的运转就是开动了生产流水线。搭建并调校出一条高转化输出能力的体系生产线，是真正具有核心竞争力和护城河的事情。</p><p>前阵子，看到新闻说台积电计划投资 250 亿美元研发建设 5 纳米制造生产线，这个投资额很好地说明了搭建一个真正具有护城河级别竞争力的生产体系所需要的成本。而台积电正是靠着这样具有核心竞争力的生产体系，成为全球半导体生产制造的霸主，制造了全球 60% 的芯片。</p><p>所以我们也要像台积电学习，好好打磨出适合自己的体系，使其真正成为自己的核心竞争力。</p><p>要想产生更大的成果，取得更大的成功，我们需要找到放大个体或团队能力的杠杆支点。曾经，也许我们也做出过好的产品，产生过好的结果，可能是我们能力不错，但也有可能只是运气不错。也就是说，好产品或好结果并不能成为支点，不断产出好结果或好产品的 “体系流水线” 才是。</p><p>我们需要做的就是不断打磨这条流水线，提升转化输出好产品或好结果的效率与良品率。</p><p>个体和团队的强弱，一方面取决于我们在体系中积蓄的力量的总量，另一方面在于体系运作的转化输出率。体系决定了力量的总量，而转化决定了拳拳到肉的痛感。</p><p>每个人做事都存在转化输出率，读完本文，你对自己或所在团队的转化输出率的提升是否有了大概的方向？</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;23-转化：能力与输出&quot;&gt;&lt;a href=&quot;#23-转化：能力与输出&quot; class=&quot;headerlink&quot; title=&quot;23 | 转化：能力与输出&quot;&gt;&lt;/a&gt;23 | 转化：能力与输出&lt;/h1&gt;&lt;p&gt;个人，建立好了知识体系，各方面都明了了，但有时做起事来却还会</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>24 | 并行：工作与学习</title>
    <link href="https://zhuansun.github.io/geekbang/posts/47579863.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/47579863.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-并行：工作与学习"><a href="#24-并行：工作与学习" class="headerlink" title="24 | 并行：工作与学习"></a>24 | 并行：工作与学习</h1><p>在工作中，你应该碰到过一些这样的情况，有同事工作的时间不短，经常加班加点，工作也很勤勉，但每每晋升时却碰壁了。你可能还会为其打抱不平过。难道这真的只是不公平或者运气不佳吗？</p><p>其实这种情况，隐藏在背后更深层次的原因是：工作陷入了循环与重复，从此停止了成长。</p><p>那么，你该如何在工作的同时，保持学习，并持续成长与进阶呢？我想，可以先从分析“程序员的工作本质是什么”开始着手。</p><h2 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h2><p>程序员的主要工作是：编程，产出代码，完成需求，交付程序系统。</p><p>程序员按其工作技能和经验，大体又分为三个阶段：初级、中级和高级。这三个级别的程序员的主要工作都是编程与产出代码，产出代码的数量也许相差不大，但产出的代码属性就可能有明显差别。</p><p>什么是代码属性？它包括资产与负债两类。由大量初级程序员产出的代码并以此构建的软件系统，如果最终能完成交付，那么很可能资产和负债性基本持平。这是很多早期创业公司产出代码的属性特征，因为创业公司早期缺乏资金和足够的知名度，难以吸引到又多又好的中、高级程序员加入。</p><p>这样的代码构建的系统多属于勉强满足业务需要，虽看不出明显的 Bug，但一遇到特殊情况就容易宕机。整个系统虽然勉强能支撑公司运营，但其中欠下了大量的技术债；先活下来，未来再来慢慢还。</p><p>若是完成了一个债务比资产还大的系统，会是个什么样的情况呢？那这就是一个还存在明显 Bug 的系统，是基本无法完成交付和上线的。</p><p>因此，现在互联网行业创业团队的主流做法，都是先完成一个资产和负债刚好过平衡点的系统，发布上线，接受反馈，再快速迭代，最后在迭代中不断地提升其资产性，降低其负债性。</p><p>这样的方式在行业里有一个实践的榜样：Facebook。它还有一句著名的标语：</p><blockquote><p>Done is better than perfect.</p><p>比完美更重要的是先完成。</p></blockquote><p>但如果你仅停留于此，那工作就永远在完成，并不会走向完美。而且，工作的内容还会不断地重复，让你从此陷入成长的停滞区。</p><p>从初、中级走向高级程序员，就不仅仅是交付代码，完成工作，还要有后续的更高要求。如：达成品质、优化效率。而在不断晋级的路上，跨越的门槛就在于此，很多人比较容易被卡在不断地在完成工作，但却没有去反思、沉淀、迭代并改进，导致一直停留在了不断重复的怪圈之中。</p><p>程序员，工作以产出代码为主，从初级到高级，代码的负债属性逐步降低，资产属性不断提升，最终成为高品质的个人贡献者。而从完成到追求品质和完美的路上，不仅仅是靠工作实践的经验积累，还需要有意识地持续学习。</p><h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><p>持续学习，是让你突破不断循环怪圈的不二法门。</p><p>在工作中，我一直有观察到一个现象，很多人因为离开学校后，工作任务多，压力大，从此就停止了系统地学习。在《浪潮之巅》一书中，吴军写道：</p><blockquote><p>国内: 小时候努力，到大学后就不努力了。</p><p>国外: 到大学后才开始努力，很快就超过国内学生。</p></blockquote><p>吴军这对比国内外的教育，也反映了我们教育中作为学生的一种心态，觉得毕业了，离开学校后就不需要多努力学习了。但目前程序员这个职业所面临的技术发展和更迭远超其他行业，你即便只是为了能够保质保量地完成任务，也需要保持持续学习的节奏。</p><p>现如今是个信息爆炸与知识过载时代，所以学习必须要有选择性。</p><p>我读大学那阵儿，学程序期间喜欢电脑，就爱帮同学人肉组装（DIY）个机什么的，而且还反复折腾安装操作系统。那时的 Windows 系统的特点之一就是越用越慢，一年半载就需要重装一次，所以可没少反复和折腾，分散了不少我的时间和精力，原本以为能主动学到新东西，但结果发现其实都是被动的。所以，学习还是要聚焦和主动选择，毕竟你的精力和时间都是有限的。</p><p>而有选择性的学习就需要找出真正与你近期规划有关的学习路径。</p><p>假如你工作入职后公司使用 Java 为主要开发语言，而大学里你一直学习使用 C 或 C++ 编程练习，这里再假设你对计算机相关的基础性学科和知识掌握良好，比如：操作系统、数据库、网络、组成原理、编译原理、算法基础、数据结构等等。那么为了更好地完成工作任务，就需要你先主动学习 Java 编程语言、开发框架等编程技术相关的知识。</p><p>而对于学习语言本身我觉得最高效的方法就是看一本该领域的经典入门书。比如，对于 Java 就是《Java 核心技术》或《Java 编程思想》，这是我称之为 <strong>第一维度的书，聚焦于一个技术领域并讲得透彻清晰</strong>。</p><p>在有了该语言的一些实际编程和工程经验后，就可以看一些该领域 <strong>第二维度的书</strong>，比如：《Effective Java》《UNIX 编程艺术》等，这些是聚焦于特定领域经验总结型的书，这类书最有价值的地方是其 <strong>聚焦于领域的思想和思路</strong>。</p><p>如果过早地看这类书反而没什么帮助，甚至还会可能造成误解与困扰。例如，我看豆瓣上关于《UNIX 编程艺术》的书评，有这么一条：“很多例子和概念已经成了古董，当历史书看，无所获。”这显然就是过早接触了第二维度的书，却预期得到第一维度的收获，自然无所获了。</p><p>而另外一些技能，像 Java 开发工作需要大量使用的开源框架又该如何学习？张铁蕾曾写过一篇《技术的正宗与野路子》，其中介绍了如何用真正 “正宗” 的方式去学习并快速掌握这些层出不穷的开源新框架和技术。</p><p>这里就借用原文里的一张图（重新按统一风格绘制了下），每一项开源框架或技术相关的学习资料可以组织成下面这张金字塔形的结构图。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/7cb9cd11da8af78da57dc4b22cabd1f6.png"></p><p>技术学习资料的层次结构示例图</p><p>Tutorial（指南） 和 API Reference（应用编程接口参考） 层次的信息资料能帮助你快速上手开发，而 Spec（技术规范）和 Code（源代码）会帮助你深刻地理解这门技术。而其他相关的技术书籍和文章其实是作为一种补充阅读，好的技术书籍和文章应该有官方资料中未涵盖的特定经验或实践才算值得一读。</p><p>张铁蕾在文中如是说：</p><blockquote><p>每当我们接触一项新技术的时候，都要把手头的资料按照类似这样的一个金字塔结构进行分类。如果我们阅读了一些技术博客和技术书籍，那么也要清楚地知道它们涉及到的是金字塔中的哪些部分。</p></blockquote><p>我深以为然，关于技术学习我们不能简单地蜻蜓点水、复制粘贴、拿来主义，应是去建立你的知识 “金字塔”，形成体系结构，而每次的学习实践都是在不断完善你的 “金字塔”。至于更多技术性学习的细节，若你感兴趣的话，也可以去看看那篇文章。</p><h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>保持学习，不断成长，工作也许还在重复，但成长却在迭代上升，然后才会有机会面临更多可选择的路径。</p><p>程序员在攀登职场阶梯的道路上，走过了高级，后面还会有好些分叉路线。比如，转到脱离技术的纯管理岗或者技术管理岗。技术主管或架构师某种意义上都属于技术管理岗，不懂技术是做不了这两个角色的；或者继续沿着深度领域走，成为细分领域专家。</p><p>这后面哪条路适合你呢？你是随大流，还是自己认真思考和决定？这是做选择题。如果一生要工作三十多年，前十年你多在做解答题，解决一个又一个问题。那么在大约走过这三分之一后，你就会开始做越来越多的选择题。为什么呢？因为一开始可能没有太多可供你选择的机会。而后续做好选择题，则需要大量学习，还需要不断地试错。</p><p>面对怎么选路的问题，我近些年学习的收获是这样的： <strong>选择走最适合实现个人价值的路</strong>。这就是我的基础选择价值观。程序员的个人价值该怎么实现？该如何最大化？程序员作为个人贡献者，到了一定的熟练阶段，产出基本就稳定了，而技能的成长却呈现对数曲线的增长特征。</p><p>任何一个你所尝试提升的事情都有一个增长曲线，这个曲线有两种形态：</p><ul><li>对数增长形态：这种类型在初期增长很快，但随后进展就越发困难；</li><li>指数增长形态：这种类型在初期增长很慢，但存在积累的复利效应。</li></ul><p>增长要么是对数形态，要么是指数形态，很少有线性的。</p><p>对数增长也意味着更容易退步，因为起步阶段是如此陡峭（见对数曲线示例图）。比如，学习一门新的技能，不持续去应用，很快就忘了，退回原点。那你应该如何应对这种“窘况”呢？我建议你在起初的高增长阶段，学习和工作的关注点需放在养成长期习惯上，因为虽然开始增长很快，但需要小心一旦停止努力它可能会向下滑落，所以一定要慎之又慎，坚持形成自己的习惯和节奏。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/9f7085a8a6d45f0ef4c30822fd58c907.png"></p><p>对数增长曲线示例</p><p>而指数增长则意味着存在一个拐点的 “突变” 时刻。很多人期望线性增长，但实际却是按指数增长的，这让许多人在拐点发生前就放弃了。比如，写作，在呈指数增长的领域内，到处都是半途而废者。所以，做本质是指数增长曲线的事情时，柔韧且持久的思维模式是关键。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/e1cecc17151781c91decf2b044c9e0d0.png"></p><p>指数增长曲线示例</p><p>工作多年后，技能的增长就又进入了对数的平缓区域，通常其回报呈现递减趋势。也就是说你在其上花的功夫越来越多，但你感到越来越难产生洞察以获得新的收益。其难处在于找到新的突破点，重新回到曲线陡峭上升的部分。</p><p>这就是所谓成长的瓶颈，你要学会应用指数增长的方法，找到价值贡献的放大器。作为程序员，你有可能很幸运地编写服务于数千万或数亿人的软件服务，这是产品自带的价值放大器。这样同是写一份代码，你的价值就是要比别人大很多。而转管理者或架构师，这些角色无非都是自带杠杆因子的，所以也有价值放大的作用。但个人能否适应得了这样的角色转换，又是另一回事了。</p><p>拉姆·查兰有本书叫《领导梯队》，书里把人才潜能分成三种： <strong>熟练潜能、成长潜能和转型潜能</strong>。原书对这三点做了详细的特征描述，我简单提炼下主要特点：</p><ul><li>熟练潜能：关注当前专业领域且十分熟练，但没有显示出在开发新能力上的努力，竭力维持现有技能。</li><li>成长潜能：按需开发新能力，显示出高于当前层级要求的其他技能，如：专业、管理、领导。</li><li>转型潜能：持续有规律地开发新能力，追求跨层级的挑战和机会，展现雄心壮志。</li></ul><p>人力资源管理中的高潜人才盘点，基本就来自这套模型，主要就是识别出这三类潜能人才。“熟练潜能” 已是我们这行对学习的最低要求，在程序员这个技术日新月异的行业里，维持现有技能确实已经让不少人感觉很竭力了。</p><p>那你拥有怎样的潜能呢？它不一定都是天赋，可能也是选择。</p><p>成长这条路从来都不是笔直的，你的“奔跑速度”也不会一直是匀速的。在每一个拐弯处，都应减速，思考，学习，然后再加速，进步。</p><p>到此我总结下今天的分享：</p><p>程序员的工作形式是编程产出代码，本质是完成需求，交付系统；但在工作中容易陷入不断完成的循环怪圈，要打破它，就需要你持续学习并有意识地关注交付代码的品质和属性，一方面提升了交付质量，另一方面也获得了个人成长。</p><p>而学习的路在时间上是永远持续的，在空间上也是有路径的；有效的学习需要你关注学习曲线的变化，遵循有体系的技术学习框架，匹配适合当前阶段的学习资源。</p><p>最后，关于工作和学习，有人总感觉有些冲突，忙起来就没时间学了。那你是怎么看待这件事呢？欢迎留言分享你的观点，我们一起探讨。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;24-并行：工作与学习&quot;&gt;&lt;a href=&quot;#24-并行：工作与学习&quot; class=&quot;headerlink&quot; title=&quot;24 | 并行：工作与学习&quot;&gt;&lt;/a&gt;24 | 并行：工作与学习&lt;/h1&gt;&lt;p&gt;在工作中，你应该碰到过一些这样的情况，有同事工作的时间不短，</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>26 | 时间：塑造基石习惯（下）——切割与构建</title>
    <link href="https://zhuansun.github.io/geekbang/posts/360649179.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/360649179.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="26-时间：塑造基石习惯（下）——切割与构建"><a href="#26-时间：塑造基石习惯（下）——切割与构建" class="headerlink" title="26 | 时间：塑造基石习惯（下）——切割与构建"></a>26 | 时间：塑造基石习惯（下）——切割与构建</h1><p>上篇，我讲述了关于建立时间习惯的第一步： <strong>感知与测量</strong>；之所以需要先感知与测量，就是为了更好地了解你的时间都花在哪里去了。</p><p>下一步， <strong>为了更有效地利用好你每天有限的时间，就需要你重新审视并调整你的时间切割与构建方式</strong>。</p><h2 id="切割时间"><a href="#切割时间" class="headerlink" title="切割时间"></a>切割时间</h2><p>时间无形，逝去匆匆，如流水、轻烟、薄雾，类似这样的比喻把时间看成无形的东西，不容易抓住和把握。但这样的比喻把时间看作了物质，物质有三态，所以轻烟也好，流水也罢，总是可以变成固态来使之更容易把握与塑造。</p><p>是的，我想说的就是转换一下你看待时间的方式，有人把它看作流水，任其从指间溜走，你却可以把它看作石头，用它去塑造什么。</p><p>一般二十岁出头我们离开校园开始工作，十年穿梭而过后，就至三十岁。古人说，“三十而立”，“立”的又是什么？无意间翻到一本旧书《大教堂与集市》，这是一本探讨程序员如何构建软件系统的书，颠覆传统，影响深远。但作为一名工程师、创建者，难道心里没有一座属于自己的大教堂？三十而立，有人也许三十已经立起了属于自己的大教堂，而有人，也许如你我，才刚刚为心中的大教堂破土奠基。</p><p>程序员有时爱把自己的工作比作 “搬砖”，有个流行的关于“搬砖”的故事，大概是这样的：</p><blockquote><p>两个工人正在工地搬石头，一个路人正好走过，就问他们在做什么？</p><p>第一个工人说：“我在把石头从这边搬过来，并垒在一起。”</p><p>第二个工人说：“我在盖一座华丽的教堂，盖好后，你再来欣赏我的作品。”</p></blockquote><p>这个故事想说明的是，虽然两个工人都在干同样的 “搬砖” 工作，但第二个工人心中有一座大教堂，也许 “搬砖” 对他的意义就会有所不同。有时想想，过去的每一天、每一刻，难道我们不是都在搬石头吗？只不过，有些石头会被用来修建心中的大教堂，而另一些石头，我们只是拿起来把玩、欣赏。</p><p>璀璨剔透的钻石，五彩斑斓的宝石，所有这些美丽、诱人的石头吸引着我们把时间花在去欣赏、迷恋它们，渐渐地就遗忘了，原来曾经我心中还有一座大教堂要建造啊，最后我们无意或有意地避开去搬起那些建造大教堂的沉重石块。</p><p>后来当时间过去，我回过头来看，在感叹别人雄奇的大教堂时，发现自己曾经把时间这块原石，切割成了一些看上去漂亮却没用的鹅卵石，更甚者只是切成了一堆土块，最后风化为一堆沙尘。所以，如今我再来看时间时，我更愿把它们切割成用来建造大教堂的石材。</p><p>记录测量时间，让我对时间的感知更精确，而面对自然产生的每天一块的“时间原石”，每个清晨就要确定：把它切成什么样？由哪些石块组成？哪些是用来建造大教堂的石材？确定后，将其压在心上，临睡前再记录下今天从心上搬走了哪些石块，以及花了多少时间。这样时间于我就真的变成了一块块石头，比轻烟、流水、薄雾更有形，更易抓住，也没那么容易悄悄地溜走了。</p><p>每天搬的石头，不一定都适合建造大教堂，而建造大教堂的时间也可能比我们预期的要长。</p><p>位于梵蒂冈的圣彼得大教堂的建造过程前后历时 120 年，由米开朗基罗设计，而文艺复兴时期的大师基本都曾参与其设计。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/490c8bc000322bfa125681c487052ab9.jpg"></p><p>圣彼得大教堂</p><p>而建造历时最长的是德国的科隆大教堂，于公元 1248 年 8 月 15 日动工，从这天起，漫长的修建科隆大教堂的道路开启。600 多年后，到 1880 年 10 月 15 日，这座荣膺当时世界最高建筑物的科隆大教堂举行了盛大的竣工典礼，成为建筑史上最杰出的成就之一。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/8fe3fa29dd689118870a11571bb811ff.jpg"></p><p>科隆大教堂</p><p>如今看到这些雄奇、壮观、让人赞叹的大教堂，再感受到建造它们的历史过程，就能真切地感觉到时间是如何被切割成了一块块的石材，构建成了最后的大教堂。</p><p>这就是关于时间的第二个 “基石” 习惯： <strong>将时间切割成建造你心中“大教堂”的合适“石材”</strong>。</p><h2 id="构建方式"><a href="#构建方式" class="headerlink" title="构建方式"></a>构建方式</h2><p>切割了时间，得到了合适的“石材”，你还需要确定适当的构建方式。</p><p>而适当的构建方式，是指在时间的 “基石” 习惯之上，建立其他的习惯。比如，好些年前开始，我会从每周的时间里切出来一块，专用于写作，慢慢就形成了写作的习惯。这意味着，我从现有的 “时间石材” 中拿出了一部分，用于构建写作的习惯，然而 “时间石材” 的总量是有限的，我必须在其上建立有限数量的习惯，我得做出选择。</p><p>每一个习惯的构建成本是不同的，甚至同样的习惯对不同的人来讲，构建成本也是不同的。比如，跑步这个事，对有些爱运动的人来说就是每天跑或每周跑几次的习惯，而于我而言，建立跑步这个习惯，从心理到生理都有更大的消耗。</p><p>任何行动的发生，都需要两种努力才有可能：第一种，是行动本身固有需要的努力，如跑步，跑一公里和跑十公里固有需要的努力是不等量的；第二种，指决策是否执行这种行动的努力，决定跑一公里还是跑十公里的决策意志力消耗，我想也不会一样。</p><p><strong>构建习惯的目的，以及它们能起作用的原因在于：它能消除行动中第二种努力的决策消耗。</strong></p><p>我之所以选择构建写作习惯而不是跑步习惯的原因是，对一个像我这样的程序员而言，写文章和写代码的感觉很接近，它就好像是一种刚好在程序员的能力边界线外不远处的事情。这样，写作行动所需要付出的两种努力，感觉都还在可以应对的范围，属于能力边界附近不远的事情，也是正适合用来扩张能力边界的事，有一种挑战的刺激感，又不至于望而生畏。</p><p>电影《功夫熊猫3》里，师父对阿宝说：</p><blockquote><p>如果你只做能力范围内的事，就不会成长。</p></blockquote><p>所以，在时间 “基石” 习惯之上构建的习惯应该是你能力范围之外的行动。如果一项行动通过习惯慢慢变成了能力范围之内的事，那么你以后再去做类似的事，其实就不需要再付出什么决策努力了，也就不再需要习惯来帮忙了。</p><p>有时，习惯会让你产生日复一日、年复一年做一件事的感觉，这样日积月累下来消耗了大量的时间，但付出了这么多未必会产生真正的收获。怎么会这样呢？</p><p><strong>习惯，它的表象和形式给人的感觉是在重复一件事，但它的内在与核心其实是不断产生交付，持续的交付。</strong></p><p>好多万年前，人类的蛮荒时期，还没有进入农业社会，人类是如何生存的？那时的人类，以采集和狩猎为生，每天年轻力壮的男人负责出去狩猎和采集野果，女人则在部落内照料一家老小。这就是进化史上，自然选择让人类养成的共同习惯，并且这个习惯持续了数十万年。</p><p>采集与狩猎这个行动习惯的核心就是必须每天产生交付，得有收获，否则一家老小都得饿肚子。而像狩猎这样的活动，就需要高度集中的注意力、熟练的技能运用和瞬间的爆发，它需要狩猎者所有的感官都高度专注在猎物的运动上，并随时调整适应猎物的运动变化。而采集，就需要采集者不断扩大或走出熟悉的边界，因为熟悉的地方可能早就没了果实，而陌生的地界又可能潜藏着未知的危险。</p><p>这样的行动习惯，通过数十万年的进化，甚至已经刻画在了我们的基因中。这就是我想说的， <strong>如果你要构建一个习惯，就要运用好基因中本已存在的关于 “采集和狩猎” 的本能：高度专注，跨出边界，持续交付</strong>。</p><p>末了，我把上、下两篇的内容一起提炼总结为如下：</p><ul><li>要形成时间习惯，要通过有意识的感知和测量来发现时间是怎么流失的。</li><li>要完成建设你心中 “大教堂”，要通过切割 “时间原石” 来完成 “时间石材” 的准备。</li><li>在养成了时间的基石习惯之上，挑选和构建其他习惯来完成 “大教堂” 的持续建设与交付。</li></ul><p>世界上多一些 “大教堂” 会变得更美好，不是吗？</p><p>关于时间，你也可以回忆一下过去的数年间，有哪些让你激动不已的时刻？曾经梦想的 “大教堂” 开始破土奠基了吗？欢迎你留言，我们一起分享和探讨。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;26-时间：塑造基石习惯（下）——切割与构建&quot;&gt;&lt;a href=&quot;#26-时间：塑造基石习惯（下）——切割与构建&quot; class=&quot;headerlink&quot; title=&quot;26 | 时间：塑造基石习惯（下）——切割与构建&quot;&gt;&lt;/a&gt;26 | 时间：塑造基石习惯（下）—</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>28 | 提问：从技术到人生的习惯</title>
    <link href="https://zhuansun.github.io/geekbang/posts/754933676.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/754933676.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="28-提问：从技术到人生的习惯"><a href="#28-提问：从技术到人生的习惯" class="headerlink" title="28 | 提问：从技术到人生的习惯"></a>28 | 提问：从技术到人生的习惯</h1><p>无论做什么工作，一路上你总会碰到各种各样的问题，而提问应是你解决问题的一种有效途径。更进一步，如果能把提问固化成为你的一种习惯，那它就不仅仅是一个解决问题的“工具”，甚至还能引导你的人生选择。</p><p>提问这个习惯，我有三个层面的理解：</p><ol><li>如何问？</li><li>问什么？</li><li>为何问？</li></ol><h2 id="如何问？提问之术"><a href="#如何问？提问之术" class="headerlink" title="如何问？提问之术"></a>如何问？提问之术</h2><p>大部分情况，我们碰到的都是已经有了问题，但却问不好，从而得不到答案或得不到好的答案。</p><p>比如说吧，我经常碰到的一种情况是：有同学常拿着一个具体的问题跑来，向我发问，他大概会交代一下想解决的场景，然后就会接着描述他的思路，以及解决这个问题的思路的一些其他约束，但这中间会有一个障碍，然后就问我该怎么解决这个障碍。</p><p>这样的发问一般都会让我陷入两种困扰之中：一种是，问题的业务背景交代得太泛化，所以我只好跟着他的思路，感觉解决这个问题似乎只能有这一条路可走；另一种则正好相反，问题的业务背景描述得过于细致，让人最后陷入对复杂业务领域的理解中，迷失在细节的讨论里。</p><p>即使是同一个场景，其实不同人还会产生不同的思路。比如：你想去一个十公里外的地方，对方也许会问你怎么套马鞍的问题，这时你就很困扰，因为你的思路是坐车或开车。这就是一个针对技术人员面对同一场景问题，所选取的不同技术方案可能处在不同的时代背景下的类比。所以，面对这类具体的障碍问题，我经常很难回答。</p><p>再看看国内网上技术问答社区的情况，我有时会去看看，发现上面的问题大部分类似下面两种模式：</p><ul><li>某某出错了，怎么办？</li><li>如何针对某某封装一个库？</li></ul><p>某某可以是一种具体的技术或框架，这两种提问模式代表了两个方向，都让人无法回答。第一种太模糊而无法回答，而第二种太庞大则不愿回答。</p><p>如果你能绕过这两个提问的大坑，提出一个具体的问题，那么算是前进了一大步。但具体问题也有一个陷阱，就如前面套马鞍的那个例子，也许有人回答了你怎么正确地套马鞍，但你可能依然走在落后的道路上，因为你的工具本身就是落后的。所以就具体问题提问，除了问及手段，还最好跟上你的目的和你就此目的是怎样提出的手段，然后才走到了这一步的障碍，让你不得不在此提问的。</p><p>一个能够回答的具体问题，一般都是解答题形式，表达清楚你的解答目的，也许你的困扰在高手那里根本就不存在。你只是走了一个弯路而已，这样不仅绕过了障碍，还获得了一条近（先进的）路，这就是有意义的提问。</p><p>至此，就得到了提问的第一个原则： <strong>提供足够的信息，让人能够回答</strong>。</p><p>草率的问题是懒惰的问题，通过搜索引擎就能简单获得；草率的问题是模糊的问题，让人没法回答。而更有意义的提问是把解答题变成选择题，提供你的选项，展现你探索了哪些路径，省去了可能产生的反问。也许你的某条路径已经非常接近答案了，只是卡在了某个点上，知道答案的人一看就明白了，也很容易回答。</p><p>这就是提问的第二个原则： <strong>提供更多的选项，让人方便回答</strong>。</p><p>即使你的问题能够回答，也方便回答，但也可能得不到回答。因为，回答问题需要有驱动力。提问本是一种索取，要让人有更多的回答动力，还需要付出。付出一种态度，表达感谢；付出一份可供交换的视角，建立讨论的基础。</p><p>这就是提问的第三个原则： <strong>提供交换价值，建立讨论基础，表达感谢态度，让人乐于回答</strong>。</p><p>《大教堂与集市》一书的作者埃里克·史蒂文·雷蒙德（Eric Steven Raymond）曾就如何提技术问题写过一篇影响颇大的文章： <a href="http://www.catb.org/esr/faqs/smart-questions.html">How To Ask Questions The Smart Way</a>（中文名是《提问的智慧》），距今已经十多年了，修订了十多次，也被翻译成了十多个国家的文字，很值得一读。</p><p>最后，我归纳下关于提问之术的三个方面：</p><ol><li>提让人能够回答的问题：草率的问题，只能得到一个草率的答案。</li><li>提让人方便回答的问题：你得到的答案的好坏取决于提问的方式和开发答案的难度。</li><li>提让人乐于回答的问题：只索取而不愿思考和付出的提问者，要么什么也得不到，要么只会得到 RTFM（Read The Fucking Manual） 或 STFW（Search The Fucking Web）。</li></ol><h2 id="问什么？求解之惑"><a href="#问什么？求解之惑" class="headerlink" title="问什么？求解之惑"></a>问什么？求解之惑</h2><p>有时一个好问题，比如何问更有价值和意义。</p><p>我觉着，前面一节关于如何提问本身也算是一个好问题，因为当你面对这个问题，找到了答案，并严肃地对待后，从此就会改变你提问的习惯。提出好问题比寻找已有问题的答案可能更有意义和价值。寻找答案，通向的是已有的结果；而提出新问题，也许会导向未知的宝藏，它可能是获得新知的起点。</p><p>有时候，你会碰到一个问题不知道该问什么，甚至该如何提问，即使这个问题是一个非常具体的技术问题。而这一类具体的技术问题，我称之为答案藏在问题中，属于无法提问的问题。</p><p>这可能说得比较抽象，下面我举个具体的例子：曾经碰到过一个线上问题，系统间隙性出现超时，只有重启能解决；而且出现的很无规律性，不和什么流量之类成正比，就是莫名其妙偶然出现，还不能恢复，只能重启。这个问题曾经困扰了我很久。这类问题虽然很具体，但你可能会发现，你竟找不到一个好方式来描述这个问题。</p><p>如果我就把上面这段描述的关键现象，偶现超时并结合使用的具体技术，如：JVM、开源框架配置和业务场景一起抛出来问人，你觉得有人能回答吗？这类就属于答案藏在问题中的问题，唯一的办法只能是找和你一起共事的同事从各人不同的思维视角去分析，抽丝剥茧。当你能找出提问的方式，基本上答案也就出来了。</p><p>后来，终于定位到上面现象的根源是服务线程池的配置有误，结合在某些慢业务场景下会引发连锁超时。这时的问题就是怎么配置服务线程池才最合理，这个问题本身就简单到完全无需再问了，自然就有了答案。</p><p>在成长的路上，我碰到过好多问题，但早年还没有形成记录与写作的习惯，所以未能把这些问题记录下来，很多就遗忘散落了。这就是我想说的第二个需要建立的习惯： <strong>当遇到暂时没有答案的问题时，先记录下来</strong>。在成长这条路上，不是碰到了问题，就能立刻或很快找到答案的。</p><p>当我开始写作后，就开始养成了这个习惯。大部分过去写的文章都来自于这些问题记录，定期地回顾下，曾经困扰我的问题，今天能解决了吗？一开始有很多具体的技术性问题，就因此写了很多技术文章。后来又有了更多复杂的问题，也就又写了不少思考性的文章。每写一篇，意味着当下的我对这个问题至少有了答案。无论这个答案如何，从某种意义上说，今天的我相比当时面临问题没有答案的我，就已经成长了。</p><p>先从一个记录问题，积攒 “问什么” 的习惯开始，不断去积累并留下一些东西，将来再定时去回顾这些问题，也许就会得到意外的收获。对于程序员，总会碰到各种技术问题，就从这些最具体的问题开始，把暂时这阶段还没法回答的问题按一种模式记录下来，比如下面这样：</p><ul><li>问题的上、下文；</li><li>问题的具体描述；</li><li>问题的解决思考和思路；</li><li>问题的解决方案和具体技术或办法；</li><li>问题解决后留下的思考或其他延伸的疑问。</li></ul><p>这就是你积累的 “宝藏”，将来如果能回答了，就把答案分享出来。这就是我所认同的积累价值和传递价值的方式，分享你从中学到的一切（Share what you learn），最后自身的价值也就得到了提升。</p><p>保持积累，持续给予，终有所获。</p><h2 id="为何问？价值之道"><a href="#为何问？价值之道" class="headerlink" title="为何问？价值之道"></a>为何问？价值之道</h2><p>提问的目标是获得答案，而答案于我们自己而言是一种价值；为何而问，就是发问于我们的价值之道，最终指向的目的是：认清自我。</p><p>值得问 “为何” 的问题不多，但总会遇到，它是一道选择题，有关我们的价值选择。我们最关心的是自己的命运，而关于命运有一句话是这么说的：</p><blockquote><p>选择决定命运，什么来决定选择？价值观。</p></blockquote><p>价值观，是我们对事情做出判断，进行选择取舍的标准。每个人都有价值观，无论你能否清晰地定义与表述它，这些观念都决定了你的行为标准。这么说有些抽象了，下面我通过一个故事来将其具象化。</p><p>这个故事的主角叫比尔（Bill）。21 岁时他成为一名程序员，获得了第一份正式工作，在加拿大多伦多的一家互动营销公司写程序，这家公司的主要客户都是一些大型药企。而在加拿大，法律限制药企直接对普通消费者做处方药的广告。</p><p>所以，药企客户提出了需求，做个网站来展示公司的药品，对于浏览网站的用户，如果能提供处方就会被引导到一个病人的专属页面。在这个专属页面上，提供了一系列的测验问题，然后通过病人的回答来推荐相关的药品。</p><p>这个网站仅仅是展示公司产品，提供通用说明的信息网站，这显然不是任何特定药物的广告。一切显得很合理，比尔收到了需求，它们包含了针对病人的测验问题，每个问题的答案，以及对答案的处理规则。</p><p>比尔完成了开发，在交付给客户之前，他的项目经理决定对网站做个简单的快速验收测试。经理试了这个针对病人的小测验，然后走到了比尔的桌前：</p><p>“测验不管用！” 经理说。</p><p>“哦，出了什么问题？” 比尔问。</p><p>“嗯，看来无论我填什么，测验都给我推荐同一种药物，唯一的例外是我回答过敏或者已经吃过了。”</p><p>“是的，这就是客户要求的处理规则，其他情况都会把病人引导到这种药。”</p><p>“哦，好吧。酷～”</p><p>经理没再说什么，他们一起交付了网站给客户，客户对这个网站很满意。项目结束后，客户的代表还邀请比尔和整个团队一起去吃一顿丰盛的牛排大餐。就在吃大餐的当晚，一位同事给他发了一封电子邮件，链接到网上的一篇新闻报道：是关于一个年轻女孩，服用了他（创建）的网站推荐的药物，然后自杀了。</p><p>网站推荐的药，其目标用户就是年轻女孩。比尔后来想明白了，他们所做的一切，建设这个网站的真正目的就是广告一种特定的药物。那时，作为团队中最年轻的开发人员，他虽然觉得客户需求的规则就是为了 “戏耍” 年轻女孩而设计的，编写的代码是 “错误” 的，但却没有多想，只是觉得这就是他的一份工作，有个开发任务要完成，而且他完成的很好。</p><p>结果后来发现，这种药物的主要副作用之一就是会让人产生严重的抑郁和自杀念头。比尔说，他可以找到无数的方法来使自己在这个事情中的角色自我合理化，但当时他依然觉得自己的代码写“错”了。那顿大餐后不久，比尔辞职了。</p><p>这就是比尔的价值观选择，他一开始是不清晰的，但这个事情让他问了自己为何，就变得越来越清晰了。我能知道这个故事，自然是比尔多年后自己写出来的。他说，“今天的代码（人工智能程序）已经开始接管你的驾驶，帮助医生诊断疾病，不难想象，它们很快也会推荐处方药。”</p><p>比尔现在依然还写代码，但自从牛排大餐那一天起，比尔都会仔细考虑代码的作用，多问一个为何？因为程序已经越来越多地占据着我们生活的方方面面，那代码背后需要价值观吗？</p><p>这就是第三个习惯： <strong>为何而问？获得答案，认清自我，选择自己的价值之道</strong>。</p><p>关于提问，今天就分享到这里，我总结提炼下：</p><ul><li>如何问，是关于提问的 “ <strong>术</strong>”，考虑让人能够回答，方便回答和乐于回答；</li><li>问什么，是关于成长的 “ <strong>惑</strong>”，去积累问题，寻找答案，并分享出来，从而完成了价值的积累、传递与交换；</li><li>为何问，是关于选择的 “ <strong>道</strong>”，价值观的选择决定了不同的道。</li></ul><p>成长的过程，一般都是从提出一个问题开始，找到答案，再融入自身的价值观，完成下一次更好的选择，周而复始，形成习惯，化作天性。</p><p>最后，你也可以想想你最近有哪些问题，是否有了答案，以及该如何提问。请在留言区写下你的思考。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;28-提问：从技术到人生的习惯&quot;&gt;&lt;a href=&quot;#28-提问：从技术到人生的习惯&quot; class=&quot;headerlink&quot; title=&quot;28 | 提问：从技术到人生的习惯&quot;&gt;&lt;/a&gt;28 | 提问：从技术到人生的习惯&lt;/h1&gt;&lt;p&gt;无论做什么工作，一路上你总会</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>29 | 偏好：个人习惯的局限与反思</title>
    <link href="https://zhuansun.github.io/geekbang/posts/509336115.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/509336115.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.645Z</updated>
    
    <content type="html"><![CDATA[<h1 id="29-偏好：个人习惯的局限与反思"><a href="#29-偏好：个人习惯的局限与反思" class="headerlink" title="29 | 偏好：个人习惯的局限与反思"></a>29 | 偏好：个人习惯的局限与反思</h1><p>经过长时间的工作实践，我们会逐步养成一些做事的个人喜好或习惯，并且会自我感觉这种个人习惯会是很好的方法。</p><p>不可否认，每个人做事情都有些个人习惯，有些特别强烈的，可能其程度还会上升到 “癖” 这个字。明朝散文家张岱在其文《陶庵梦忆》中留有名句：“人无癖不可与交，以其无深情也。”这里的 “癖” 就是指一个人强烈的个人喜好与习惯。</p><p>作为程序员，过去这么些年干得最多的事情自然就是写程序，关于写程序也会形成一些个人习惯或者说癖好。自己的习惯或癖好对别人本该是无所谓的，但在团队合作中，有些时候，我们可能会不自觉地去维护，甚至推广这种习惯。这种 “不自觉” 的行为是值得我们警惕和反思的。</p><h2 id="习惯形成"><a href="#习惯形成" class="headerlink" title="习惯形成"></a>习惯形成</h2><p>工作中的一些习惯是如何悄悄形成的呢？</p><p>记得毕业几年后，我也成了需要带新毕业学生的 “老” 程序员。其中，带学生的主要任务之一就是一起做项目，指导他们上手开始写真正的项目代码，而不再是实验性质的课程作业。</p><p>我开始工作的头几年，可以说是我写程序最多的几年，基本也就写出了我个人的一些习惯和喜好。比如，工程的目录结构、类的命名模式、接口的参数定义，甚至注释和签名的方式，都是我特别在意的地方。每当看到新同学们各自按自己的想象写得随心所欲，就感到非常地焦心。</p><p>那时候像 Java Maven 这种约定优于配置的工具还没有流行起来，大家都是按自己的喜好使用 Ant（一种 Java 构建工具）来定义工程项目结构，所以最终导致结构千差万别。</p><p>因而，我就忍不住去把新同学们的工程按我自己的定义喜好进行修改，以一种权威的说辞来强调自己的偏好：“我们要统一下，免得像以前旧项目一样差异太大，换个项目熟悉起来都要好半天，也不利于相互之间的代码交流。”</p><p>如今回想起来，当时这种 “约定优于配置” 的个人习惯在行业里还并没有成为共识，而我仅仅是出于自己对代码的 “洁癖” 或者说强迫症，就产生了这种强加于人的冲动行为。一些年后，Maven 崛起逐步取代了 Ant，这种约定优于配置的方式就变成了 Java 程序员的普遍共识，而我，也可以确认这个习惯基本算是一个好方法，也不再需要去强迫别人了。</p><p>以上，就是一个关于编程习惯的形成过程。从中我们可以看出，即使这样的习惯最后也许真的变成了大家认同的好方法，一开始也不该以个人的方式直接去强加于人。因为强加于人，总是容易带来分歧和争论，最终可能好习惯还没机会带来收益，却因为分歧争论直接带来了损失。</p><p>但编程中总结出来的一些方法和原则，很多可能就是始于个人习惯，最后逐渐传播并演化形成了普遍共识。</p><h2 id="共识达成"><a href="#共识达成" class="headerlink" title="共识达成"></a>共识达成</h2><p>如今，很多约定俗成的代码规范，基本就是从早期一些人的习惯中加以提炼总结出来的，然后形成了大家共同认可的好方法，并在组织层面形成了规范。形成了规范的东西，就不再是从个人习惯的角度去强加于人了，而是大家的共识达成。</p><p>写代码的一些方法能形成规范，但还有一些编程的好方法可能比较难用规范去描述，这些就慢慢形成了所谓的 “编程智慧”，并在程序员之间口口相传（如今的 “口口” 可能更广义一些，也包括了互联网上的文字交流和传播）。</p><p>一些 “编程智慧” 类的好方法，不太好形成具体的规范描述。下面，我就结合我自己的工作经历和经验，列举一些规范建议：</p><ol><li><strong>设计模式</strong>。遵守设计模式总是能让你少踩坑的，但如何灵活地采用合适的模式又是另一种智慧了。</li><li><strong>术语约定</strong>。约定了术语，总是能让口头的概念和落在代码上的东西保持一致，减少沟通歧义，从而更高效。</li><li><strong>单元测试</strong>。这比任何的代码评审都来得可靠，哪里该写多少测试用例，哪里可以不写，这又是智慧了。但不要刻意为了追求覆盖率而去写，覆盖率的技术统计方法其实是很唬人的，有些覆盖率很高的项目，该有的 Bug 还是有的。</li><li><strong>随时重构</strong>。对于技术债务，每个月付点“利息”，比好几年后“连本带息”去还要感觉轻松得多。这条的特殊点在于，这可能是大部分程序员都认可的好方法，但却不是大部分人的习惯。因为技术上的债，实在自己还不起，总是可以推脱出去给下个“倒霉的家伙”，但从长远角度看，这样的推脱不会让你获得成长，甚至还会阻碍你的发展。</li></ol><p>在程序界形成编程共识最经典的例子来自 Unix 的发展历史，而 Unix 几十年的发展历程，不仅仅是一个软件系统的进化，也是程序设计和编程方式的进化。从它的进化历程中，形成了独特的设计原则，而且已广为流传，达成共识。</p><p>共识，意味着看待问题共同的思考方式和角度，所有能形成共识的方法都是值得关注的。</p><h2 id="分辨反思"><a href="#分辨反思" class="headerlink" title="分辨反思"></a>分辨反思</h2><p>编程中除了好方法，还有些确实只是个人习惯的东西，如果我们不去留心区分，很容易模糊了两者的界限。</p><p>举个例子，我曾经一直有个编程习惯是这样的。假如有一个查找接口方法叫 lookup()，而实现这个方法内部的逻辑要根据好几种条件来查找，按不同的参数条件来实现不同的内部逻辑分支，但最后执行时又会走同样的一段逻辑去存储里查找。这样描述起来比较绕，下面我用个简图来说明：</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/ded4a70a4c19c670aa662c38fa9e6cc5.png"></p><p>我个人编码中的方法命名习惯图例</p><p>如上，lookupByXXX 表达了不同参数逻辑的差异化处理，最后的 lookup0 则是一段共享的查找执行代码。 lookup 是一个公开的接口方法，而后面再加个 0 基本就是我的个人习惯了，表达了内部私有的一种技术性实现，它一定是私有的，不对外暴露的。</p><p>这个例子中的编程方法，是让我对所有类似需要的接口实现模式保持一致。但这确实只是我个人的习惯偏好，我没办法并且也不会要求别人也用类似的方式来命名函数和编写实现，因为别人也可能有自己的习惯偏好，谈不上谁比谁更好，毕竟它并不是广泛的共识。</p><p>那大家都认同并形成共识的方法就一定能形成习惯吗？也未必，这需要我们去分辨和反思。比如程序员都不爱写文档，很多人也没有这个习惯，但大家几乎都认同提供规范的设计和接口文档是个好方法，只是因为文档的优先级长期低于完成代码功能从而被搁置了。</p><p>另外，一些流行的概念就一定是好方法吗？比如，结对编程，是一种流行的概念。它的行为要求是：两位程序员坐在同一工作台前开发软件。它的优势作用是：与两位程序员各自独立工作相比，结对编程能编写出质量更高的代码。其理论基础是：两个程序员具有相同的缺点和盲点的可能性很小，所以通过结对编程的时候会获得一个更好的代码实现。</p><p>但在实际中，结对编程也有它的缺点和劣势，比如更高的开发成本（毕竟要同时占用两个人）。而且，有些人可能从心理上就很不喜欢结对编程的，比如我，因为坐在一起编程，难免分心而无法进入完美的心流状态，所以会感觉自己的工作效率都会下降一半以上；并且我也很难接受别人在看代码讨论时，用手戳屏幕指指点点。当然，不仅仅是我，还有更甚者，除了代码洁癖，还有生活洁癖，根本接受不了任何其他人和自己共用一个键盘的。</p><p>也许稍微松散点，没有那么物理上的严格结对，而是确保每一个程序员写的每一行代码，都能有一个配对的程序员去进行检视，虽说这个过程完全是异步或远程的，但效果应该也是可以保障的。这几乎就是开源项目的协作模式。开源项目的繁荣与成功，也证明了其实践的协作模式是一种好方法。</p><p><strong>总结来说</strong>：</p><p>在你从程序新人成长起来的过程中，要学会区分，哪些确实是值得学习与推广的好方法，哪些仅仅是自己的个人习惯，特别是在你成长到开始成为技术管理者之后。</p><p>古语有云：“己所不欲，勿施于人。”而己之所欲，若是自己特有的习惯偏好，也就请勿妄施于人了。若确实觉得是个好方法，尽量建议于人，而非强加于人，即使你手上掌握有强加的权力。</p><p>反过来看，程序行业，编程实践中，存在大量流行的概念、模式、原则，甚至哲学，它们的产生都有其历史背景和过程，并在一定范围内形成了共识。但你依然需要去对这些流行的共识进行分辨和反思，看看哪些才是适合你的好方法。若真是好方法，也可以进一步将其培养成自己的习惯。</p><p>虽是以编程为例，但习惯的偏好不限于此。</p><p>最后，在你成长的路上，都形成了哪些好习惯呢？欢迎你留言给大家分享下。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;29-偏好：个人习惯的局限与反思&quot;&gt;&lt;a href=&quot;#29-偏好：个人习惯的局限与反思&quot; class=&quot;headerlink&quot; title=&quot;29 | 偏好：个人习惯的局限与反思&quot;&gt;&lt;/a&gt;29 | 偏好：个人习惯的局限与反思&lt;/h1&gt;&lt;p&gt;经过长时间的工作实践</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>30 | 写作：写字如编码</title>
    <link href="https://zhuansun.github.io/geekbang/posts/3139595197.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/3139595197.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.646Z</updated>
    
    <content type="html"><![CDATA[<h1 id="30-写作：写字如编码"><a href="#30-写作：写字如编码" class="headerlink" title="30 | 写作：写字如编码"></a>30 | 写作：写字如编码</h1><p>程序员群体有个共同的弱点，那就是写得了代码，解决得了问题，但却不能很好地展现自己的能力。从今天开始，咱们专栏即进入一个关于 “展现” 的主题，聊聊（写作、画图和演讲）三类最常见的展现手段。</p><p>其中，展现的最常见形式之一就是： <strong>写作</strong>，它是一种能随着时间去沉淀的长尾展现形式。</p><p>曾有多人问起，写作除了坚持写、持续写、长期写，还有什么其他技巧么？答案是：有的。虽说我并没有上过专业的写作课，但在长期的写作过程中，我已通过实践摸索出来了一套符合程序员这种理性逻辑思维的写作技法，简言之，就是：写字如编码。</p><p>把每一篇文字当作一个需求，把写作当成在编码的过程去完成这个需求，它会非常类似于程序开发的整个过程，包括 <strong>需求、设计、实现、测试和交付</strong> 五个阶段。</p><h2 id="一、需求"><a href="#一、需求" class="headerlink" title="一、需求"></a>一、需求</h2><p>程序的需求，对应于写作的主题。</p><p>你之所以写程序，是因为有人给你提需求；但你业余的写作，通常就不会有人给你提相关的写作需求或主题了。所以，就需要你自己去主动寻找和发掘你自己的写作需求或主题。</p><p>对于我来说，写作主题的来源可以有很多方面：有时，是来自身边的工作和生活中的事件引发的感触；有时，是阅读过程中突然产生的启发与领悟；有时，则是曾经一直困惑的问题突然碰到或找到了答案……这些都属于灵感乍现的时刻，也是我写作主题的来源。</p><p>但只是等到写的时候去灵光一现是很难保障持续写作的主题供应的，所以为了持续写作，我很多时候在大脑的潜意识里都会考虑主题的问题，等有了灵光一闪的时刻，就随时记录下来，形成一个 <strong>主题列表</strong>。这个主题列表，就有些像产品的需求特性列表了，呆在需求池里等待被 “实现”，也即，“写出来”。</p><p>所以，如果你想要持续地写作，你得养成一个习惯，也就是前面《提问：从技术到人生的习惯》一文中关于提问和记录的习惯。</p><p>随手记录的主题可能很多，但真正能写的时间和精力却有限，因此你得挑选值得写的主题。如果把每一篇文字想象成一件产品，那么定义写作的主题，就像定义产品的灵魂，你得确定一个产品的目标、定位，以及面向的读者人群。</p><p>美国作家库尔特·冯内古特说：</p><blockquote><p>想一个你关心，其他人也会关心的话题来写。要记住，不论你用多么发自肺腑的情感表达，对于读者来说，除非是他们真正关心的主题，不然怎么都不会太关心，而只有主题才是读者最真切的关注点。所以，关注你的主题，而不是想办法去显摆自己的文字。</p></blockquote><p>是的，一个好的主题很可能是一篇好文字的开端，毕竟如果一开始产品方向错了，实现得再好又能有多大意义呢？</p><h2 id="二、设计"><a href="#二、设计" class="headerlink" title="二、设计"></a>二、设计</h2><p>确定了本次写作的主题（需求），接下来就该进入到设计阶段了。</p><p>而程序开发的设计一般分为两个层面：</p><h3 id="1-概要设计"><a href="#1-概要设计" class="headerlink" title="1. 概要设计"></a>1. 概要设计</h3><p>在软件程序系统的设计中，这部分内容主要是架构设计，系统或子系统的拆分、交互逻辑、边界等等。而对于写作而言，这部分对应的就是设计本篇文字的逻辑结构，换言之，即在主题确定的基础上，采用怎样的逻辑去展开主题，形成合适的衔接。</p><p>比如，我写的文章多为随笔散文类，而散文的结构，上过中学语文课的我们都知道：形散而神不散。其中的 “神”，就包括了文章的核心主题观点，以及围绕主题展开的逻辑结构、文字附着的延展线条等。</p><h3 id="2-详细设计"><a href="#2-详细设计" class="headerlink" title="2. 详细设计"></a>2. 详细设计</h3><p>有了逻辑骨架后，就需要补充真正有血有肉的文字了。</p><p>围绕主题想表达的观点，考虑需要添加哪些支撑观点的素材，以及设计整理、引出和排布这些素材的方式。而为了让文字更有阅读的趣味，还需要有适当的故事，因为人们都喜欢读故事，而非说教，那故事又该如何切入与布局？这也是需要考虑的点。</p><p>另外，这些素材或故事又从哪里来？只能来自平时的阅读积累。大部分我们读过的东西很快就会被遗忘，所以为了在需要的时候找到合适的内容，就需要在平时的阅读时记录笔记，留下索引，必要时再根据笔记索引的关键词去搜索。</p><p>经过了编程强大且反复的逻辑训练后，对于你、我写作而言，逻辑结构的设计就不该有障碍了，其实最大的差异与障碍可能是在 “实现” 上。</p><h2 id="三、实现"><a href="#三、实现" class="headerlink" title="三、实现"></a>三、实现</h2><p>写文字和编码在实现层面最大的差异是：实现过程的技能和要求不同。</p><p>在实现技能层面，程序是用计算机语言来表达的，文字是用自然语言来表达的。计算机语言的逻辑性和精确表达能力要比自然语言强得多，自然语言是模糊的、混沌的、不精确的。因此写得一手好程序的人，不一定能写得一手好文字，因为他们需要驾驭的语言的特性完全不同。</p><p>刚开始写文章时，即使自然语言我们从小就学会了，也能熟练使用，但用它写起文章来也会有一种磕磕碰碰的感觉。就好像刚学写程序时，好不容易才能编译通过，也是磕磕碰碰的。</p><p>对于编码，编译通过的程序才算刚刚开了头，接着还会进行程序的调测，有时还会优化重构。对于写文字也需要类似的过程，毕竟一气呵成地写出一篇完美的文章，就像是个不可实现的传说。其中，代码重构中的重命名、分拆过长的函数等，就类似于对文章重新进行文字的遣词造句、润色打磨、段落分界等过程。</p><p>另外，之于编程和写作，不同的技能应用水平，实现效果就完全不同了。写过程序的都知道同样的架构设计，选择不同的语言、框架、算法和数据结构来实现，实现的技能水平要求可谓千差万别。而同样主题和逻辑结构的文章，不同文字技能水平的作者来写，高下立见。</p><p>比如，网络小说兴起之后，我也看过一些，对男主角人物的描写，多是男神化。用词无非，帅则温润如玉、玉树临风；正则气宇轩航、丰神俊朗。但太过正的角色还不行，又会加点邪气，如狂浪不羁等描述，这样更讨读者喜欢。再对比下金庸是如何描述类似这样的人物的：</p><blockquote><p>这本来面目一露，但见他形相清癯，丰姿隽爽，萧疏轩举，湛然若神。</p></blockquote><p>短短四组词，一个身形清瘦、风度俊爽、洒脱轩昂、目光有神却又透出一股子高处不胜寒的人物——黄老邪——就跃然纸上了。金庸用词简练而韵味深长，境界高下立判。这就是文字技能的应用水平了，就像武功招式。金庸在文字上浸淫多年，随手用出一招，自是比普通人精妙许多。</p><p>写程序和写文章，本是两种不同的 “武功”，“心法” 可以类似，但 “招式” 自不相同。而 “招式” 的积累与应用，无论写程序还是写文字，都没有什么捷径可走，只能多看、多写、多练。</p><p>除此之外，写程序和写文字的实现过程的环境要求也有类似之处：程序员写代码的时候很讨厌被人打断，需要一段能安静且专注的时间，通常2～4 小时不等。写作也一样。所以，我经常选择在晚上夜深人静的时候进行写作的 “实现” 阶段。</p><p>这一点，不仅程序员是这样，很多知名作家也都有自己独特的写作过程要求，他们的共性都是需要一段能实现不被打扰且专注的时间。</p><p>村上春树，当他进入创作小说的写作模式时，他通常早晨 4 点起床，连续写作 5 到 6 个小时，然后会去跑上 10 公里或游 1500 米（或者二者都有）。下午就不再写作，而是读点东西，听听音乐，晚上 9 点便上床睡觉。他日复一日地保持这样的作息时间、这样的重复过程，据称能帮助其进入一种思维的深层状态。</p><p>海明威，通常是早晨天一亮就开始动笔。在采访中，他说道：“没有人打扰你，早晨凉爽，有时候冷，你开始工作一写就暖和了。你读一遍你写好了的部分，因为你总是在你知道往下写什么的时候停笔，你写到自己还有活力、知道下面怎样写的时候停笔。”他通常每天只写 500 字，而且喜欢用一只脚站着，采取这种资势，据称可以使他处于一种紧张状态，迫使他尽可能简短地表达自己的思想。</p><p>实际上，这些年写作下来，我也尝试了在很多不同的时间段，甚至分多次写完一篇文章。这里没有一定之规，你总会找到适合自己的写作实现方式。在这个过程中，你有一段专注、忘我甚至像是做梦的过程，与自己的思维深处对话。</p><p>在这个过程中，你也可能会产生意外的大脑神经元连接，获得一些更高质量的思考，灵光乍现的启发，以及更好的文字表达。</p><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>每次写完一篇文章后，就感觉自己好像是被清空了，甚至不再想去读一遍，这时我就会把它“扔”在一边。</p><p>写作的过程中，大脑从冷的状态逐步升温，直到进入一种很热的状态，文字就是在这样的状态下自然流淌出来的。直到写完之前，大脑一直在高速运作，就像一颗 100% 利用率的 CPU，它的温度很高。写完后，CPU 终于降低了负载，但温度的降低还需要一个过程。</p><p>而对写完的文字再读一遍，进行再编辑和优化，这就像软件开发中的测试过程。但我需要在一个冷却的状态下进行，站在一个读者或编者的视角去重新审视这篇文章。所以，这个过程通常发生在写作完成后的一天或几天之后。这中间的间隔，我称之为写作后的冷却时间。只有在冷却的状态下，我才能更客观地检视自己写的文字，同时进行合适地编辑和修改，这个过程就是对文字的测试。</p><p>作为程序员，其实我并不喜欢做太多的测试工作，所以在以前我写作完，只是“履行”最简单的文字测试内容：必要的错别字、用词理解性和语句流畅性检查。和 “极客时间” 合作写专栏就给配备了专业的编辑，编辑主要会从下面几个方面进行测试或检查。</p><ul><li>文词使用：进一步发现有时作者自己很难发现的错别字和用词的适当性、理解性问题；</li><li>逻辑结构：整体文字内容的逻辑结构，衔接过渡是否自然等；</li><li>读者感受：站在读者的角度，去考虑其感受以及能够得到的收获；</li><li>……</li></ul><p>这就是关于文字的测试，就像一个好的测试总是能帮助开发者得到一个更好的软件一样，一个好的编辑也总是能帮助原作者形成更好的文字输出。</p><h2 id="五、交付"><a href="#五、交付" class="headerlink" title="五、交付"></a>五、交付</h2><p>完成了必要的编辑测试工作后，就到了最终的交付（发布）阶段。</p><p>写作本身是一个不断积累压力的过程，而交付之后则完成了一种压力的释放与转换。关于这一点，和菜头描述得特别精确：</p><blockquote><p>写作真正的压力来自于完成一件事情的压力，你要么一开始连个标题都想不出来，要么写两段之后就不知道如何继续下去。写第一篇文章会是一次漫长而痛苦的自我挣扎，你大概有 30% 的精力花在构思内容上，剩下 70% 的精力花在自我怀疑和自我否定上。</p></blockquote><p>而交付，就是发布这篇新写的文字，让它面对读者，获得反馈与验证价值。</p><p>交付一篇新的文字，就像是往这个互联网的文字海洋中扔下一滴水珠，偶尔也会激起几丝涟漪。时有读者留言、评论，或有赞，或有踩，而从作者的角度出发，交付的目的之一是希望有一些更有价值、值得思考和讨论的声音出现。</p><p><strong>写作与文字的价值实现分两部分，写完后就完成了对自我的价值实现，而交付后才算完成了对他人的价值实现。</strong></p><p>当你把写作拆解成了类似编码的过程，也许阻碍你写作的障碍与阻力也就变得没那么大了。如果你能编写清晰有效的代码，也就应该能写出主题结构清晰的文字。至于一开始文字的好坏，技巧的高明与否，反而并不重要，在持续写的过程中，它们会自然而然地得到提升。</p><p>方法有了，还需要找到写作的源动力，而大部分作者的源动力都来自于一颗想要表达的心；再配合一部分外部的激励机制，和相应的自律约束，才有可能持续地写下去。</p><p>最后，多说一句，极客时间上的留言质量很多都不错，如果你还没有开始写点东西，不妨从留言开始记录一些你的思考和观点，留下价值。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;30-写作：写字如编码&quot;&gt;&lt;a href=&quot;#30-写作：写字如编码&quot; class=&quot;headerlink&quot; title=&quot;30 | 写作：写字如编码&quot;&gt;&lt;/a&gt;30 | 写作：写字如编码&lt;/h1&gt;&lt;p&gt;程序员群体有个共同的弱点，那就是写得了代码，解决得了问题，但</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>32 | 演讲：表达的技术</title>
    <link href="https://zhuansun.github.io/geekbang/posts/66040861.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/66040861.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="32-演讲：表达的技术"><a href="#32-演讲：表达的技术" class="headerlink" title="32 | 演讲：表达的技术"></a>32 | 演讲：表达的技术</h1><p>展现的另一种形式是： <strong>演讲</strong>。其实作为程序员出身的我，演讲水平非常有限，但在职业发展与成长的道路上，演讲却是必经之路。所以，我确实有比较系统地思考和琢磨过演讲的价值、效果以及提升的方法，现在我将其分享给你，希望能对你的成长或者职业道路有所帮助。</p><h2 id="一、价值与效果"><a href="#一、价值与效果" class="headerlink" title="一、价值与效果"></a>一、价值与效果</h2><p>写作的展现，是一种广度路线，产生间接、长尾效应；演讲的展现，是一种深度路线，产生直接、深度连接。</p><p>为什么说写作是广度而演讲是深度的？过去几年，我读过很多的文章、书，但还能记得住只言片语的都非常少。即使当时一些给我非常多启发与触动的文字，如今也只能记得当时触动的感觉，却忘了触动的内容。但好些年前，我参加过几次行业大会，有那么几场演讲，现在回想起来，不仅记得当时深受启发的触动感，甚至还能记得当时的内容。</p><p>这就是演讲带来的深度效应，它的现场感更立体，有助于留下更深刻的记忆，持续发挥影响的时间也超过了文字。</p><p>演讲的现场立体感带来的深度效应，也只能留在现场。即使我们把整个演讲过程录制成为视频，观看视频的过程也会损失很大一部分深度影响力，也许这就是为什么有人会去看现场演唱会的原因。</p><p>所以，演讲的最大价值就在于这样的深度效应。但现场感并不一定带来深度影响，也可能是把人 “催眠” 了。那如何发挥好演讲的效果呢？这里我就先谈谈我自己的一些经历和感悟。</p><h2 id="二、经历与感悟"><a href="#二、经历与感悟" class="headerlink" title="二、经历与感悟"></a>二、经历与感悟</h2><p>成长路上，终究会遇上演讲；从没遇上演讲的程序员，可能天花板就会比较低。</p><p>作为程序员，我的第一次演讲经历，当然是技术分享，团队内部的。如今回想，第一次分享暴露出了很多方面的问题。比如，材料准备时发现 PPT 技能太差，想展现的内容做出来的效果太挫；现场讲的时候容易跑偏或者陷入细节，整体节奏失控；想表达的内容太多，信息量过大。这些问题都导致第一次演讲的效果不尽如人意。</p><p>后来再有技术分享的机会时，我已经开始写作了一段时间，发现写作实际对演讲是有帮助的。写作和演讲的共通处在于：内容、观点、信息传递的目标都是要考虑的，只是最终的表达形式不同。而且因为写了不少东西，也反而获得了更多的技术分享机会。</p><p>从业这么些年，经历了从线上到线下，从组内到部门，然后再到公司或行业级的不同规模的分享演讲，挑战并不一样，其中最大的区别在于现场感的压力不同。而且除了分享式的演讲，还有另外一种汇报式的演讲，如：晋升述职。</p><p>技术分享，一般时间会长一些（一小时左右），而晋升述职，时间则要短很多（十分钟左右）。前者的压力来自对象的规模，后者的压力来自对象的角色。</p><p>而不同时长的演讲，准备的方式也不太一样。时间长的演讲，准备的内容就多，要精确地讲好这么多内容是一个挑战；而时间短的演讲，内容不多，但就需要合适地挑选和裁剪，并且精确地传递，这又是另外一种挑战。</p><p>那对于不同的演讲类型，有通用的准备方法吗？下面我们尝试梳理下。</p><h2 id="三、准备与发挥"><a href="#三、准备与发挥" class="headerlink" title="三、准备与发挥"></a>三、准备与发挥</h2><p>一场演讲，包括前期准备和现场发挥两个阶段，而前期充分的准备是现场良好发挥的基础。</p><p>世界上有一个著名的演讲论坛 TED，它上面的演讲，即使仅仅是视频，很多都给人留下了深刻的印象，而且传播范围也很广。它的演讲者通常是一些知名人士或至少是业内影响力比较大的人物。</p><p>我一开始以为他们本身就已经是很好的演讲者了，但后来了解到他们为了参加 TED 短短十来分钟的演讲，需要全力以赴地投入以周为单位的时间。比如，《哈利波特》的作者罗琳去 TED 演讲时，为此全心投入准备了整整六周。</p><p>那前期可以准备的内容有哪些？我梳理了有如下维度：</p><h3 id="1-框架"><a href="#1-框架" class="headerlink" title="1. 框架"></a>1. 框架</h3><p>演讲的框架和程序的架构有点类似，一般我都从下面几个方面来设计：</p><ul><li><strong>目标</strong>：本次演讲需要达成的目标是什么？</li><li><strong>听众</strong>：本次演讲的受众是哪些人？</li><li><strong>重点</strong>：本次演讲要传递的关键点有哪些？</li></ul><p>那么一场技术分享的框架线，可能有如下：</p><ul><li><p><strong>引出主题</strong>：结合目标与听众来确定。</p></li><li><p><strong>自我介绍</strong>：让听众了解你，证明你有资格讲这个主题。</p></li><li><p><strong>重点结构</strong>：每一个关键点的分析、讲解，可以从以下方面来拆解。</p><ul><li>问题：这个点上存在什么问题？</li><li>历史：这个问题的历史由来是什么？</li><li>方法：你是用什么方法解决这个问题的？</li><li>原因：为什么要用这个方法，要在这个阶段，以及这样解决问题？</li></ul></li><li><p><strong>细节深入</strong>：有一定细节深入，更有说服力。</p></li><li><p><strong>总结回顾</strong>：结束前的再次总结和提炼，以加深印象。</p></li></ul><h3 id="2-材料"><a href="#2-材料" class="headerlink" title="2. 材料"></a>2. 材料</h3><p>在框架线清晰后，就进入了演讲材料的准备阶段。其中的材料包括三类：</p><p><strong>第一类是幻灯片</strong>。到底要准备多少页的幻灯片？这个取决于框架线和演讲时长。但这里幻灯片的最大作用在于：</p><ul><li>辅助演讲者的结构记忆与信息表达；</li><li>辅助听众的信息吸收、理解与消化。</li></ul><p>也就是说，演讲的主角还是讲，而幻灯片仅仅是配角。</p><p><strong>第二类是演讲稿</strong>。讲之前你可以先写下来你所要讲的内容，这样会有助于组织信息、梳理逻辑和提炼语言。</p><p>TED 的演讲以前多是18分钟，而现在分长、短两种：短的约6分多钟，长的也缩减到了12～15分钟。在信息爆炸的时代，听众的注意力是一种稀缺资源，想要吸引这样的注意力，就需要提供更精确且直击人心的内容，才能收获你想要的深度影响效果。</p><p>我们的正常语速大约是每分钟150～200个汉字，但在演讲的压力环境下，可能会出现不自觉地加速，无意识地跑偏，甚至语无伦次。如果想要提供更精确的信息传递和表达，那么演讲稿就是必需的。</p><p>让演讲的每一个字，都体现它的价值。</p><p><strong>第三类是小故事</strong>。人是情感动物，故事的影响效应远高于数据和逻辑，即使是在做技术分享时。</p><p>以前听过一些技术分享感觉比较枯燥、催眠，就在于技术基本都在讲逻辑、讲数据，听久了自然疲劳。而穿插一些 “小” 故事，则可以加深前面数据和逻辑的影响效应。这一点很多慈善募捐组织早就学会了，再大比例的穷困数据，也比不上一张衣不蔽体的小女孩照片来得有效。</p><h3 id="3-节奏"><a href="#3-节奏" class="headerlink" title="3. 节奏"></a>3. 节奏</h3><p>一段持续时间的演讲中，有没有一些关键的时间点呢？当然是有的。</p><p><strong>一个是开场</strong>。据研究统计，一场演讲给人留下的印象和评价，开场的数秒至关重要。这可能和一开始是否能抓住听众的注意力有关。</p><p><strong>另一个是峰终</strong>。管理界有一个 “峰终定律（Peak-End Rule）”：在 “峰” 和 “终” 时的体验，主宰了对一段体验好或者不好的感受，而在过程中好或不好体验的比重、时间长短，对记忆的感觉差不多没有影响。也就是说，如果在一段体验的高峰和结尾，你的体验是愉悦的，那么你对整个体验的感受就是愉悦的，即使这次体验总体来看，更多是无聊和乏味的时刻。</p><p>峰终定律，在管理上决定了用户体验的资源投入分布，只需要重点投入设计好 “峰终” 体验。而演讲，也是一门体验艺术，它的 “峰” 前面说了一处——开场（抓注意力）；另一处，可能是中间某一处关键点（提供独特的高价值内容或观点）。</p><h3 id="4-表演"><a href="#4-表演" class="headerlink" title="4. 表演"></a>4. 表演</h3><p>演讲，包括讲和演，因而还有最后一个准备环节：演。</p><p>演，即表演和发挥；表演的准备，有三个层级，如下图（原图来自 Tim Urban’s Memorization Spectrum，翻译后重绘制）：即兴发挥、框架内发挥和严格遵从剧本。</p><p><img src="https://note-1252548816.cos.ap-nanjing.myqcloud.com/uPic/202312/f25fe75fa3dfe192c01cf7b82f15d7e0.png"></p><p>表演准备的三个层级</p><p>做了前述准备的演讲，算是在框架内发挥。如果还准备了演讲稿，那么练习熟练后，基本算是接近了 3A 这个层级，但演讲稿，还算不上是剧本，所以只是接近。按 3 这个层级的准备，是把演讲当作了一出舞台剧，有严格的剧本，需要经过反复地排演练习。</p><p>这样的准备投入是巨大的，所以你一般需要判断到底多么重要的演讲，才需要用上 3 这个层级的准备。但即使达不到 3 级的标准，按这个标准来准备也有好处，当你非常熟练了你想要精确表达的内容，在现场发挥时，你的大脑就会从记忆负担中腾出空间来应对临场那些很难提前准备的状况。</p><p>“演” 需要关注和练习的东西比 “讲” 多得多，而且表演本身就是一种专业，甚至也是一种天赋。这条路上，你可以先有一个清晰的认知，但能做到何种程度，可能因人而异吧。</p><p>演讲，本是表达的艺术，但对程序员的要求远没到艺术的层次；先能表达，再求精确，技术达标，足矣。</p><p>关于展现的第三种形式：演讲，就分享到这了；而演讲也是很多程序员的一道槛，如今的你遇到这道槛没？欢迎你留言分享。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;32-演讲：表达的技术&quot;&gt;&lt;a href=&quot;#32-演讲：表达的技术&quot; class=&quot;headerlink&quot; title=&quot;32 | 演讲：表达的技术&quot;&gt;&lt;/a&gt;32 | 演讲：表达的技术&lt;/h1&gt;&lt;p&gt;展现的另一种形式是： &lt;strong&gt;演讲&lt;/strong&gt;</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>35 | 关系：学徒与导师</title>
    <link href="https://zhuansun.github.io/geekbang/posts/1286842990.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/1286842990.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="35-关系：学徒与导师"><a href="#35-关系：学徒与导师" class="headerlink" title="35 | 关系：学徒与导师"></a>35 | 关系：学徒与导师</h1><p>现在很多公司都有一种带新人的导师（Mentor）制度，导师制的初衷是为了帮助新员工快速熟悉公司环境，并提供工作技能和个人成长的帮助，正所谓 “传帮带”。</p><p>这是用制度建立并约束了一种在新、老员工之间的关系，这本是一个很好的出发点。但想要类似这样的制度关系发挥期望的作用，恐怕就需要 “导师” 和 “学徒” 都有一个更高层次的清晰认知，毕竟制度只能在其中起到催化的作用。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>导师制诞生于十四世纪，随之带来的是一场翻天覆地的变化。</p><p>突然之间，那时的年轻男女们可以用自己最富余的资产——时间，去交换当时最稀缺的资源——培训。在那个时代，经验丰富的手艺人，比如，铁匠、鞋匠、木匠等，他们指导这些年轻人，并承诺将来某天年轻人能学会他们的技能然后去开创属于自己的事业。作为交换，年轻人会提供低成本且廉价的劳动力。</p><p>作为学徒，年轻人可能赚不到什么钱，但却能学到关于这门手艺的各种经验和技巧。比如：一个铁匠学徒，能学会或掌握如何去建造高温火炉，组合不同的金属以产生不同熔点的合金混合物，以及制作耙、刀或犁等工作技能。这些经验和技巧，在当时的学校里是都教不了的，只能进入这行业去获得第一手的经验。</p><p>那么程序员这行的导师制，像是中世纪时期那样吗？似乎有点像，但也不完全一样。我们都知道编程这门手艺，你读的书再多、再好也不如真正动手去做。可是你一旦开始做了，也会很快掉入迷宫，因为路径千万，到底怎样才是对的？怎样才是好的呢？所以，现在好多公司都会说，“我们会为新员工或学生配备有经验的‘导师’来领路……”但，很多有经验的程序员并不能很好地理解（这也包括曾经的我），作为 “导师” 到底该做什么？要怎么做？以及做或不做于自己有什么关系？</p><p>比如，一个有经验的程序员，走到一名新员工面前，问：“你会 Java 吗？会这个框架吗？”</p><p>“学过 Java，但框架不太懂。”</p><p>“来，这里是框架文档地址，你先看看，搭个 demo 先跑起来。”</p><p>“恩，…”</p><p>这样的场景，也许大量存在于新手程序 “导师” 和 “学徒” 之间。</p><h2 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h2><p>有经验的程序员、老员工，站在 “导师” 的视角，会如何看待这样的关系呢？</p><p>从某种意义上来讲，经验丰富的程序员，就和中世纪的老师傅一样，他们经历了大量的时间犯过大量的错误，积累了很多难以言说的经验价值。他们已经经历过你所犯的错误，已然能够轻松应对如今让你痛苦和头疼的问题，所以他们具有能够引导你迈向正确方向的潜能。</p><p>但反过来想，他们为什么要指导你？只是因为公司有个导师制，并安排了他成为你的导师？那么这样的指导通常也就变成了上面那种场景。为什么他们要牺牲自己的工作时间，甚至私人时间来无私地指导你？也许作为新同学的你，甚至包括制度的制定者本身，可能也没从这个角度来看待该问题。</p><p>但如果不从这个角度来思考一种制度，那么很可能制度期望的是一回事，行动起来却是另一回事。若只是通过单纯的职业道德约束或价值观教育是解决不了这个问题的。毕竟中世纪的老师傅还可以靠利益交换与绑定来稳固这个机制和关系的。</p><p>大学里读研读博，也会有个导师。这样的导师，相对比职场的导师更进一步，因为你们之间有经济交换，你交了学费，所以学校导师就对你的毕业负有一定的指导责任。但你能获得多少质和量的指导与帮助，其实取决于你的态度和反馈。</p><p>所以你看，学生参加导师接的一些项目，本质上和中世纪的学徒提供廉价劳动力换取经验和指导是一样的。还有些学生，会为导师收集材料，用于发论文或写书，有些甚至干脆就是写好了论文或书，最后导师只是署个名。人品好点的导师可能还会给你留个第二作者的位置，差点的也许你连露脸的机会都没有。</p><p>而职场导师制，如果公司没有相应足够的考核、评价和激励制度支撑，那么这种师徒关系实际上没有任何约束，完全靠运气、投缘之类的。站在导师的角度，对于凑巧碰到的一个职场新人，他有什么样的利益或情感驱动要去更积极地做这件事呢？其实最直接的，还是由对方的态度和行动来驱动的。</p><p>而在没有这些更实质的驱动因素时，有人如果愿意去积极地做这件事，那一定是在更高的维度看这件事。借用一句话来说明：</p><blockquote><p>取得领先的方法，就是提携你身边的人。你对待别人的态度始终会伴随你，人们会忘记你所说和所做的一切，但永远不会忘记他们对你的感觉。帮助别人就是影响别人，如果你能帮很多人，你本身就是高手，你的影响力就很大，你就能做更大的事。</p></blockquote><p>这是一个气度问题。</p><h2 id="学徒"><a href="#学徒" class="headerlink" title="学徒"></a>学徒</h2><p>反过来，站在 “学徒” 的视角，该如何看待这样的关系？万维钢有篇文章叫《给前辈铺路的人》说得很有现实意义：</p><blockquote><p>给人当学徒，就给你提供了这个机会。你现在把自己和一个高手连接在了一起，你可以从内部了解第一手的经验。这就是学徒工作的协议：用礼敬和服务，换取机会——而这个机会还不是立功露脸的机会，而是学习实践的机会。</p></blockquote><p>机会，就是得到更快的成长与发展。从导师多年积累的经验中获益，能够缩短获得这些知识经验的时间，并且避免重复错误。但这里面可能还有个障碍，就是自尊心的问题，态度不够谦虚，那么也许是性格还需磨练。如果态度谦虚，双方都投入了适当的时间和精力，那么导师当年花了十数年才学会或领悟到的东西，学徒也许只用短短几年就能学到，绕过了没必要的重复路线。</p><p>从学徒方面来说，必要的、简单的、低技术含量或重复性的工作也是必须的，不应该被认为是一种浪费或牺牲。当你在免费获得大量的知识和帮助的同时，却抱怨时间投入太多，或者时间不够，其实是短视的。因为：</p><blockquote><p>当你给人铺路的时候，你实际上也在左右他的前进方向。</p></blockquote><p>这也是一个气度问题。</p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>师徒关系有很多种，最让你期待的是哪一种？</p><p>对我来说，联想起师徒关系，一下映入我脑中的是金庸小说《笑傲江湖》中的令狐冲和风清扬。在看这部小说时，也曾梦想遇见自己的 “风清扬”，学会绝代天下的独孤九剑。但后来随着年龄增长，我开始觉得，现实中也许终究不会存在像 “独孤九剑” 这样的绝艺，也不会有风清扬这样的师傅，直到我遇到一位美国作者德里克（Derek），他在自己的文章里分享了一个他的成长故事。</p><p>下面，我就从作者的第一人称来简述下这个故事。</p><h3 id="学徒视角"><a href="#学徒视角" class="headerlink" title="学徒视角"></a>学徒视角</h3><p>那年夏天，暑假，我 17 岁了，高中刚毕业。开学后，我就将进入伯克利音乐学院学习音乐。那时，我困惑于一些音乐问题，又找不到人解答。所以，我随机打给了一个本地的音乐工作室，工作室的主人基莫（Kimo）接起了电话。</p><p>我们聊了起来，当他听说我将去伯克利学音乐时，他说：“我就是从伯克利毕业的，之后还留在那里教了好些年的音乐。我打赌，我能在几节课内教会你学校安排了两年的音乐理论与编曲课程。另外，假如你能明白‘不要接受学校速度的限制’这个道理，我猜你也许能在两年内毕业。假如你感兴趣的话，明天上午 9 点来我的工作室上课，当然，这是免费的。”</p><p>两年内毕业？太棒了，我喜欢这个风格，实在太激动了。第二天一早，8:40 我就到了他的工作室门口，但我等到了 8:59 才按响了门铃。</p><h3 id="导师视角"><a href="#导师视角" class="headerlink" title="导师视角"></a>导师视角</h3><p>一天早上的8:59，我的门铃响了，我当时完全忘了为什么这么早会有人来。一直以来，我偶然遇见过一些孩子，他们都说想成为伟大的音乐人。我告诉他们，我能提供帮助，然后让他们早上 9 点来我的工作室，但遗憾的是从来没有人早上 9 点来过。这就是我从一堆孩子中识别出那些只是随便说说，还是真正认真严肃地想干点事的人的办法。直到那天，他来了，按响了我的门铃，一切就这么开始了。</p><p>后来的故事就是，德里克只用了两年半便从伯克利毕业了，并将这个抬高的标准和速度应用在了之后一生的事业与生活中。而他们也从师徒关系，转化成了朋友关系，维持了几十年，直到今天。</p><p>这像不像一个现实版的 “令狐冲” 与 “风清扬” 的故事？而这，就是我期待的一种师徒关系。</p><p>现实中，对于师徒关系，会有人有这样的疑问：“教会徒弟，会饿死师傅吗？”也许中世纪时期的师徒关系会有这样的担忧，但如今这个信息时代，知识根本不稀缺，也没有所谓的 “一招鲜，吃遍天” 的绝招。反过来说， <strong>带好了徒弟，接手并取代了你当前正在做的事情，你才有可能解放出来去做更高层次和更大维度的事情</strong>。</p><p>而作为学徒，你需要吸取德里克的经验： <strong>学习和成长是自己的事，严肃待之，行动起来，自助者，人亦助之</strong>。</p><p>在成长的阶梯上，无论你在阶梯上的哪个位置，都可以努力去寻找和建立这样一种关系，最好的状态，我想应该既是学徒又是导师。你觉得呢？</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;35-关系：学徒与导师&quot;&gt;&lt;a href=&quot;#35-关系：学徒与导师&quot; class=&quot;headerlink&quot; title=&quot;35 | 关系：学徒与导师&quot;&gt;&lt;/a&gt;35 | 关系：学徒与导师&lt;/h1&gt;&lt;p&gt;现在很多公司都有一种带新人的导师（Mentor）制度，导师制</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>38 | 思维：科学与系统——两类问题的两种思维解法</title>
    <link href="https://zhuansun.github.io/geekbang/posts/4044098762.html"/>
    <id>https://zhuansun.github.io/geekbang/posts/4044098762.html</id>
    <published>2023-12-13T18:36:22.000Z</published>
    <updated>2023-12-13T15:14:51.658Z</updated>
    
    <content type="html"><![CDATA[<h1 id="38-思维：科学与系统——两类问题的两种思维解法"><a href="#38-思维：科学与系统——两类问题的两种思维解法" class="headerlink" title="38 | 思维：科学与系统——两类问题的两种思维解法"></a>38 | 思维：科学与系统——两类问题的两种思维解法</h1><p>写了多年代码，做了好多的工程，不停地完成项目，但如果你一直仅仅停留在重复这个过程，那么就不会得到真正的成长与提高。你得从这些重复做工程的过程中，抽象提炼出真正解决问题的工程思维，用来指导未来的工程实践。</p><p>什么是 <strong>工程思维</strong>？我从自己过往经验中提炼出的理解是： <strong>一种具备科学理论支撑，并成体系的系统化思维</strong>。做了多年的软件开发工程，碰到和解决了数不清的问题，最终这些问题，我发现稍微抽象一下，可以归为以下两类：</p><ol><li>可以简单归因的问题：属于直接简单的因果关系；</li><li>难以简单归因的问题：属于间接复杂的因果关系。</li></ol><p>上面的描述可能有点抽象，那具体该怎么理解呢？这里我分别举两个例子：线上有个 Bug，找到了有问题代码片段，需要一个优化实现方案来解决，这就是第一类问题，原因和结果非常明确清晰；线上老是出故障，而且反复总出意外故障，对于这个结果，它的原因是什么，这就很难简单归因了，就属于第二类问题。</p><p>对于这两类问题，我想讲讲两种不同的思维框架提供的解法。</p><h2 id="科学与理论"><a href="#科学与理论" class="headerlink" title="科学与理论"></a>科学与理论</h2><p>第一类问题，现象清晰，归因明确，那么它唯一的难处就是为这个问题找到最优的解决方案。求解最优化问题，就需要科学与理论的支持，也即： <strong>科学思维</strong>。</p><p>先讲一个其他行业的故事：造船工程。很早以前，关于应该造多大的船，人们都是靠感觉摸索的。后来（十九世纪中期）有个英国工程师布鲁内尔（Brunel）意识到船应该尽可能造得大些，于是他设计了当时世界上最大的船。这是一艘挑战当时工业极限的船，该设计甚至还引发了当时社会激烈的辩论。</p><p>布鲁内尔的目标是建造一艘足够大的船，大到无需中途停留，直接能从英国开到印度，那么如此远的航程就需要有足够的货物与燃料（那时的燃料主要就是煤）的装载能力。而支撑他设计背后的理论却很简单，船的装载能力是体积决定的，跟船尺寸的立方成正比，而船航行受到的阻力则是和船底的面积成正比。所以，船越大，装载能力越大，但单位载重量的动力消耗却下降了，这就是为什么布鲁内尔要尽可能地造大船。</p><p>这就是科学理论给予造船工程的方向指引。吴军老师也曾在一篇文章《计算机科学与工程的区别》里指出：</p><blockquote><p>科学常常指出正确的方向，而工程则是沿着科学指出的方向建设道路；在工程中必须首先使用在科学上最好的方法，然后再作细节的改进。</p></blockquote><p>我做在线客服系统时碰到一个问题和滴滴打车的匹配问题非常类似，打车是人和车的匹配，而咨询客服是人和客服的匹配。抽象来看，这个匹配的算法并不复杂，但因为涉及到非常具体且繁琐的业务规则，实现起来就有特别多业务逻辑，导致性能有问题。这就是软件工程现实中的第一类问题，需要找到优化方案。</p><p>对于这类问题的解法，就是先用计算机科学理论来分析其性能的复杂度边界与极限，而咨询分配就是在 N 个客服里进行挑选匹配，每次只匹配一个人，所以理论复杂度极限是 O(N)。只要 N 有限大，那么匹配的性能最坏情况就是清晰的。</p><p>理论分析给出了边界，工程实现则是建设道路，这就需要在边界里找到最短路径。在客服匹配问题的工程实现总考虑的方式是：最坏的情况是每次匹配都要遍历 N 次，最好的情况是 1 次，那么实现方案评估就是尽可能让最好的情况发生的概率最大化。假如你的实现方案 90% 的场景概率都发生在最好情况下，10% 的场景发生在最坏情况，那么整体性能表现可能就比最坏情况高至少一到数个量级。实际提高多少，这取决于 N 的大小。</p><p>而另一个工程实现考虑的维度是，如果每次匹配中有 M 个高消耗操作，那么进一步的优化方式就是如何减少 M 的个数或降低每次操作的消耗。</p><p>这就是用科学思维来指导工程实践，科学理论指出方向，探明边界，工程实践在边界的约束范围内修通道路，达成目标。正如前面故事中，造船理论往大的方向走也有其极限，因为除了能源利用率的经济性外，越大的船对其他建造、施工和运营方面也会带来边际成本的提高，所以也就没法一直往大里造，这就是工程现实的约束。</p><p>所以，理论的意义不在于充当蓝图，而在于为工程设计实践提供有约束力的原理；而工程设计则依循一切有约束力的理论，为实践作切实可行的筹划。</p><p><strong>简言之，科学理论确定了上限，工程实践画出了路线</strong>。</p><h2 id="系统与反馈"><a href="#系统与反馈" class="headerlink" title="系统与反馈"></a>系统与反馈</h2><p>第二类问题，结果明确，但归因很难，那么找到真正的原因就是第一个需要解决的难点。这时，我们就需要用另一种思维方式： <strong>系统思维</strong>。</p><p>回到前面举的例子，线上老是出故障，而且反复出意外故障。如果简单归因，查出故障直接原因，发现是代码写得不严谨，实现有不少漏洞和问题，仔细看就能分析出来，但触发条件罕见不容易测出来，于是提出解决方案是增加代码评审（Code Review）流程来保障上线代码的质量。</p><p>关于代码评审就是我从业多年来遇到的一个非常有意思的问题，大家都觉得它有用，也都说好，但很多时候就是执行不下去。因为它不是一个简单问题，而是一个系统问题。万维钢在《线性思维与系统思维》这篇文章里，给出了一些系统问题的典型特征，其中有两条是这样说的：</p><ul><li>多次试图解决一个问题，却总是无效；</li><li>新人来了就发现问题，老人一笑了之。</li></ul><p>我呆过的很多公司和团队，都想推行代码评审，最后都无果而终。反而是一些开源项目，还搞得有声有色。还是万维钢的那篇文章里，其对系统的定义：“所谓系统，就是一个由很多部分组成的整体，各个部分互相之间有联系，作为整体又有一个共同的目的。” 简单想想就会发现公司项目所在的 “系统” 和开源项目所在的 “系统” 其构成就完全不同，而且目的也不同。</p><blockquote><p>一个系统中可以有若干个正反馈和若干个负反馈回路，正反馈回路让系统或者增长、或者崩溃，是要偏离平衡，负反馈回路则尽力保持系统的平衡。</p><p>对你想要解决的这个问题而言，可能就有一个回路，正在起主导的作用！如果你能发现在系统里起主导作用的回路是什么，你就抓住了系统的主要矛盾，你就找到了问题的关键所在。</p></blockquote><p>曾有行业大牛在前公司有很好的代码评审传统和流程规范要求，自己也坚决支持代码评审。后来去了另一个同行差不多规模的公司，进入到团队后想推行代码评审时，就遭遇了巨大的阻力，不止是 “老人呵呵，一笑了之” 了，还甚至被公开地反对了。显然，对于代码评审这个问题，他的前后两家公司拥有完全不同的正、负反馈回路，以其个体之力，想要去改变已有的反馈回路，其实相当艰难。</p><p>我自己也曾在团队做过一些尝试，但一直找不到合适地建立正反馈回路的好方法。引入严格的代码评审流程，其负反馈回路立刻发生作用：更多的工作量，更多的加班等。负反馈，团队立刻就能感知到，而其正反馈回路发生作用带来好处却需要一定的时间。而且另一方面，建立新的回路或者摆脱当前的循环回路，还需要额外的能量来源，也即激励。</p><p>在解决系统问题，建设正反馈回路上也有过成功的样本。比如，在公司层面要求工程师产出专利，这对个体来说就是额外的负担，而负担就是负反馈。为了降低负反馈回路的作用，可以让专利和晋升到一定级别关联上，并增加专门培训来降低写作门槛；专利局每通过一份专利，就奖励一笔奖金（几千到上万），甚至没通过都能奖励几百块，这些就是建立正反馈循环回路的激励能量。</p><p>另外一个例子是，为了让程序工程师们更有分享的意愿和提升表达能力，就出一个规则，把分享和每年的晋升提报关联起来，本质就是提供了潜在可能的经济激励。经济学原理说：人会对激励做出反应。是的，经济学原理很有效。</p><p>软件工程，是研究和应用如何以系统性的、规范化的、可度量的过程化方法去开发和维护软件；而实际上软件开发本身就是一个系统工程，里面存在很多没法简单归因的第二类问题，它们没有通用的解法，只有通用的思维。</p><p>一个优秀的工程师应该同时具备科学思维和系统思维，它们是工程思维的两种不同表现形态： <strong>系统思维洞察问题本质，科学思维发现最优解法</strong>。</p><p>学完本章，你也可以去细心观察你周围的环境，看看都有哪些问题，属于哪类问题，以及你能发现它们的本质吗？欢迎你留言分享一二。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;38-思维：科学与系统——两类问题的两种思维解法&quot;&gt;&lt;a href=&quot;#38-思维：科学与系统——两类问题的两种思维解法&quot; class=&quot;headerlink&quot; title=&quot;38 | 思维：科学与系统——两类问题的两种思维解法&quot;&gt;&lt;/a&gt;38 | 思维：科学与系</summary>
      
    
    
    
    <category term="程序员进阶攻略" scheme="https://zhuansun.github.io/geekbang/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E9%98%B6%E6%94%BB%E7%95%A5/"/>
    
    
  </entry>
  
</feed>
